/**
 *	Common script between Elite and Heroes
 *
 *	Warning: This script can't be used alone and is only meant to be extended by Elite and Heroes
 */
#Extends "Modes/ShootMania/ModeMatchmaking.Script.txt"

#Const	CompatibleMapTypes	"EliteArena, HeroesArena"
#Const	ModeSportVersion	"2014-07-23"
#Const	ModeSportScriptName	"ModeSport.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/Toss.Script.txt" as Toss
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_Mode				0		as _("Mode 0: classic, 1: free")		///< Less restrictive mode for casual play
#Setting S_TimeLimit		60		as _("Attack time limit")				///< Time for an attack on a map
#Setting S_TimePole			15		as _("Capture time limit")				///< Time allowed to reach the pole by the end of the attack
#Setting S_TimeCapture		1.5		as _("Capture duration by pole")		///< Time to capture a pole for the attack clan (* NbPoles)
#Setting S_WarmUpDuration	90		as _("Warmup duration (0: disabled)")	///< Duration of the warmup
#Setting S_MapWin			2		as _("Number of maps to win a match")	///< How many maps a clan has to win to win the match
#Setting S_TurnGap			2		as _("Minimum points gap to win a map")	///< Points lead necessary to win a map
#Setting S_TurnLimit		15		as _("Default map points limit")		///< Maximum number of points before next map
#Setting S_DeciderTurnLimit	20		as _("Decider map points limit")		///< Points limit on decider map
#Setting S_QuickMode		False	as _("Less time between rounds")		///< Mutliplier for the sleep times between rounds
#Setting S_UseLegacyCallback True	as "<hidden>"							///< Send the old JSON callbacks
// Clublinks settings
#Setting S_UsePlayerClublinks		False	as _("Use players Clublinks")	///< Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1		""		as "<hidden>"	///< Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2		""		as "<hidden>"	///< Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_DisplaySponsors			True	as "<hidden>"	///< Display the sponsors of the attacker when spectating him
#Setting S_RestartMatchOnTeamChange	False	as "<hidden>"	///< Restart the match after the warm up if the teams have changed
// Elite Practice settings
#Setting S_Practice				False	as _("Play in practice mode")
#Setting S_PracticeRoundLimit	3		as _("Number of attack turns by player in practice mode")


#Const C_WURocketAmmoMax			4	///< Rocket ammo max
#Const C_WURocketAmmoGain			1.	///< Rocket ammo regen speed
#Const C_WULaserAmmoMax				1	///< Laser ammo max
#Const C_WULaserAmmoGain			1.	///< Laser ammo regen speed
#Const C_WUNucleusAmmoMax			1	///< Nucleus ammo max
#Const C_WUNucleusAmmoGain			1.3	///< Nucleus ammo regen speed
#Const C_DefStaminaMaxMultiplier	0.7 ///< Stamina amount multiplier for the defense
#Const C_AtkStaminaMaxMultiplier	1.	///< Stamina amount multiplier for the attack

#Const C_AtkArmorMax	300	///< Starting armor for atk players
#Const C_DefArmorMax	100	///< Starting armor for def players

#Const C_WinTimeLimit			1
#Const C_WinCapture				2
#Const C_WinAttackEliminated	3
#Const C_WinDefenseEliminated	4

#Const C_WeaponLaser	1
#Const C_WeaponRocket	2
#Const C_WeaponNucleus	3

#Const C_ModeClassic	0
#Const C_ModeFree		1

#Const C_WaitConnectionTimeLimit	60000

#Const C_SpecRefreshInterval	250 ///< Interval between the refresh of the spectators properties
#Const C_SequenceWarmUp			1	///< Scores table mode warm up
#Const C_SequencePlaying		2	///< Scores table mode playing
#Const C_SequencePodium			3	///< Scores table mode podium
#Const C_UI_Colors [
	"BG"		=> "222d",
	"Separator"	=> "eeef",
	"Text"		=> "fffc"
]

#Const C_BlueBotsNb	3	///< Blue bots number
#Const C_RedBotsNb	3	///< Red bots number

// ---------------------------------- //
// Command
// ---------------------------------- //
#Command Command_MatchPointsClan1			(Integer)	as _("Match points for clan 1")
#Command Command_MatchPointsClan2			(Integer)	as _("Match points for clan 2")
#Command Command_CurrentMapPointsClan1		(Integer)	as _("Current map points for clan 1")
#Command Command_CurrentMapPointsClan2		(Integer)	as _("Current map points for clan 2")
#Command Command_PreviousMapsPointsClan1	(Integer)	as _("Previous maps points for clan 1")
#Command Command_PreviousMapsPointsClan2	(Integer)	as _("Previous maps points for clan 2")
#Command Command_TieBreakDefElimClan1		(Integer)	as _("Tie break defender elimination for clan 1")
#Command Command_TieBreakDefElimClan2		(Integer)	as _("Tie break defender elimination for clan 2")
#Command Command_ForceFirstAtkClan			(Integer)	as _("Force first attacking clan on the map (1: Blue, 2: Red)")
#Command Command_ForceTossWinner			(Integer)	as _("Force toss winner (1: Blue, 2: Red)")
#Command Command_ForceWarmUp				(Boolean)	as _("Set pause")
#Command Command_ForceClublinkReload		(Boolean)	as _("Force clublink reload")

// ---------------------------------- //
// Globales variables
// ---------------------------------- //
declare Integer G_AtkClan; 						///< Define wich Clan is currently attacking (1 player)
declare Integer G_DefClan; 						///< Define wich Clan is currently defending (3 players)
declare Integer	G_CheckpointsNb;				///< Number of checkpoints				
declare Integer[Integer] G_MapScores;			///< Number of map won by each clan
declare	Integer[Integer] G_MatchAtkPoints;		///< Number of successful atk for each clan during the match
declare	Integer[Integer] G_MatchDefElim;		///< Number of defenders eliminated by each clan during the match
declare Integer[Integer] G_MatchBestCaptureTime;///< Fastest capture time for each clan during the match
declare Integer[Integer] G_MatchPoints;			///< Number of points cumulated since the beginning of the match
declare	Integer[Integer] G_MapAtkPoints;		///< Number of successful atk for each clan during the map
declare	Integer[Integer] G_MapDefElim;			///< Number of defenders eliminated by each clan during the map
declare Integer[Integer] G_MapBestCaptureTime;	///< Fastest capture time for each clan during the map
declare Integer[Integer] G_TieBreakDefElim;		///< Number of defenders eliminated by each clan during the tie break
declare Integer[Integer] G_AtkSlot;				///< Current atk slot
declare Ident	G_AtkPlayerId;					///< Current atk player Id
declare Ident	G_AtkElimPlayerId;				///< Id of the player who eliminated the atk
declare Vec3	G_MapSpecCamDirection;			///< Spectator camera orientation
declare Text	G_LongestRailName;				///< Name of the player with the longest Laser hit
declare Real	G_LongestRailDistance;			///< Distance of the longest Laser hit
declare Integer	G_LastSpecUpdate;				///< Last time the spectators were updated
declare Boolean G_TieBreak;						///< Match is in tie break
declare Boolean G_UseEliteB2;					///< Use the Beta 2 gameplay
declare Text[]	G_TempAllies;					///< Logins list of matchmaking temporary allies
declare Ident[]	G_PrevMapUsersIds;				///< The list of users from the previous map 

declare Integer G_Override_FirstAtkClan;
declare Integer G_Override_TossWinner;
declare Boolean G_Override_NeedWarmUp;
declare Boolean G_Override_ForceClublinkReload;

// ---------------------------------- //
// Extend
// ---------------------------------- //

***LogVersion***
***
MB_LogVersion(ModeSportScriptName, ModeSportVersion);
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Json::GetScriptName(), Json::GetScriptVersion());
MB_LogVersion(Toss::GetScriptName(), Toss::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(WarmUp2::GetScriptName(), WarmUp2::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

// ---------------------------------- //
// Server initialization
// ---------------------------------- //
***InitServer***
***
declare VoteClanNb = 0;
declare FirstAtk = MathLib::Rand(1, 2);
declare OldMode = GetMode();
declare WinnerTurnClan = -1;		///< Winner Clan for a turn
declare WinnerMapClan = -1;			///< Winner Clan for a map
declare WinnerSubmatchClan = -1;	///< Winner Clan for a submatch (KotM)
declare WinnerMatchClan = -1;		///< Winner Clan for a match
declare WinType = -1;				///< Type of victory for the turn: timelimit = 1, pole capture=2, etc.
declare SleepMultiplier = 1.;		///< Multiply the different sleept times of the script by this value
declare IsRematch = False;			///< Do the players want a rematch ?
declare RematchNb = 0;				///< Number of consecutive rematch

declare netwrite Integer Clan1MapPoints for XmlRpc;
declare netwrite Integer Clan1MatchPoints for XmlRpc;
declare netwrite Integer Clan2MapPoints for XmlRpc;
declare netwrite Integer Clan2MatchPoints for XmlRpc;
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***StartServer***
***
// ---------------------------------- //
// Init Settings
VoteClanNb = 1;
MB_UsePlayerClublinks	= S_UsePlayerClublinks;
UsePlayerTagging = True;
G_AtkSlot = [1 => 1, 2 => 1];
WarmUp2::Load();
WarmUp2::CreateGroup("Clan1", S_NbPlayersPerTeamMax);
WarmUp2::CreateGroup("Clan2", S_NbPlayersPerTeamMax);
WarmUp2::DisplayClanSelection(True);

// ---------------------------------- //
// Create rules
---Rules---

// ---------------------------------- //
// Layers creation
// UI All
Layers::Create("ScoresTable", CreateLayerScoresTable());
// UI Players
Layers::Create("SpawnScreenAttack");
Layers::Create("SpawnScreenDefend");

Layers::SetType("ScoresTable", CUILayer::EUILayerType::ScoresTable);
Layers::SetType("SpawnScreenAttack", CUILayer::EUILayerType::ScreenIn3d);
Layers::SetType("SpawnScreenDefend", CUILayer::EUILayerType::ScreenIn3d);

Layers::Update("SpawnScreenAttack", UpdateLayerSpawnScreen("Attack"));
Layers::Update("SpawnScreenDefend", UpdateLayerSpawnScreen("Defend"));

UIManager.UIAll.ScoreTableOnlyManialink = True;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
***

// ---------------------------------- //
// Match initialization
// ---------------------------------- //
***InitMatch***
***
declare Integer TossWinner;
declare MapSkipped = False;
***

// ---------------------------------- //
// Match start
// ---------------------------------- //
***StartMatch***
***
if (MB_UseScriptCallbacks && S_UseLegacyCallback) XmlRpc.SendCallback("BeginMatch", Json::Enfold(Json::Merge([Json::Stringify("MatchNumber", MB_SectionMatchNb), Json::Stringify("MapRestart", MB_MapRestarted)])));
// ---------------------------------- //
// Initialize match goal average
G_MapScores				= [1 => 0, 2 => 0];
G_MatchAtkPoints		= [1 => 0, 2 => 0];
G_MatchDefElim			= [1 => 0, 2 => 0];
G_MatchBestCaptureTime 	= [1 => 0, 2 => 0];
G_MatchPoints			= [1 => 0, 2 => 0];

// ---------------------------------- //
// Set mode options
UseClans = True;
MB_UseSectionRound = True;
MB_UseSectionTurn = True;

G_PrevMapUsersIds = Ident[];
G_Override_FirstAtkClan = -1;
G_Override_TossWinner = -1;
G_Override_NeedWarmUp = False;
WinnerMatchClan = -1;
TossWinner = -1;
***

// ---------------------------------- //
// Map initialization
// ---------------------------------- //
***InitMap***
***
declare CSmMapLandmark[] Goals;
declare CSmMapLandmark[] Checkpoints;
declare Boolean WinByForfeit;
declare Boolean TokenUsed;
declare Text PrevClan1Color;
declare Text PrevClan2Color;
declare Save_MatchDefElim = G_MatchDefElim;
declare Save_MapDefElim = G_MapDefElim;
declare Save_TieBreakDefElim = G_TieBreakDefElim;

UIManager.UIAll.MarkersXML = ""; ///< Remove the markers from the previous map for the intro
if (MM_IsMatchServer()) MB_UseIntro = False;
else MB_UseIntro = True;
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***StartMap***
***
if (MB_UseScriptCallbacks && S_UseLegacyCallback) XmlRpc.SendCallback("BeginMap", Json::Enfold(Json::Merge([Json::Stringify("MapNumber", MB_SectionMapNb), Json::Stringify("MapRestart", MB_MapRestarted)])));
G_MapSpecCamDirection = GetOverviewCamDirection();

// ---------------------------------- //
// Initialize anchors
Goals = CSmMapLandmark[];
Checkpoints = CSmMapLandmark[];
foreach (Pole in MapLandmarks_Gauge) {
	if (Pole.Tag == "Goal A" || Pole.Tag == "Goal B" || Pole.Tag == "Goal C") Goals.add(Pole);
	else if (Pole.Tag == "Checkpoint") Checkpoints.add(Pole);
}
G_CheckpointsNb = Checkpoints.count;
// Compatibility with old MapType
if (Goals.count <= 0) {
	MB_Log("Old MapType compatibility");
	declare OldPole <=> Map::GetLandmarkGauge("Goal", 0);
	if (OldPole != Null) Goals.add(OldPole);
}

// ---------------------------------- //
// Initialize all scores
Score::MatchBegin();
G_MapAtkPoints			= [1 => 0, 2 => 0];
G_MapDefElim			= [1 => 0, 2 => 0];
G_TieBreakDefElim		= [1 => 0, 2 => 0];
G_MapBestCaptureTime	= [1 => 0, 2 => 0];

foreach (Score in Scores) {	
	declare NbHit for Score = 0;
	declare NbElimination for Score = 0;
	declare NbBeHit for Score = 0;
	declare DefRatio for Score = 0.;
	declare LaserLongest for Score = 0.;
	declare LaserHit for Score = 0;
	declare LaserShot for Score = 0;
	NbHit = 0;
	NbElimination = 0;
	NbBeHit = 0;
	DefRatio = 0.;
	LaserLongest = 0.;
	LaserHit = 0;
	LaserShot = 0;
}
ClanScores[1] = 0;
ClanScores[2] = 0;
foreach (Player in AllPlayers) {
	declare netwrite Net_LayerST_DefPoints for Player = 0;
	declare netwrite Net_LayerST_AtkPoints for Player = 0;
	Net_LayerST_DefPoints = 0;
	Net_LayerST_AtkPoints = 0;
}

// ---------------------------------- //
// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// ---------------------------------- //
// Initialize UI
//UIManager.ResetAll();
InitUi();
SpawnScreen::AttachRules();
Clublink::Attach();
Clublink::SetSponsorsDisplay(False);
Layers::Attach("ScoresTable");
Layers::Update("ScoresTable", CreateLayerScoresTable());
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
PrevClan1Color = Teams[0].ColorText;
PrevClan2Color = Teams[1].ColorText;

if (MM_IsMatchServer()) {
	Layers::Attach("SendToServer");
}

---RulesReminder---

// ---------------------------------- //
// Initialize roles for first round
G_AtkClan = FirstAtk;
G_DefClan = 3 - FirstAtk;
FirstAtk = G_DefClan;	// Swap for next map.
G_AtkSlot = [1 => 1, 2 => 1];

Users_SetNbFakeUsers(C_BlueBotsNb, C_RedBotsNb);

WinnerTurnClan = -1;
WinnerMapClan = -1;
WinnerSubmatchClan = -1;
WinByForfeit = False;
TokenUsed = False;
G_AtkPlayerId = NullId;
G_LongestRailName = "-";
G_LongestRailDistance = 0.;
G_TieBreak = False;
G_TempAllies = Text[];
declare NeedWarmUp = True;
declare MapWinnerName = "";
---SelectNextMap---

// ---------------------------------- //
// Wait players on first map when using matchmaking
if (MM_IsMatchServer()) {
	if (MB_SectionMapNb <= 1 && !MapSkipped && !IsRematch) {
		MM_MatchWait();
		MM_VoteForNextMap(True);
		PrepareMatch();
	}
}
MapSkipped = False;
IsRematch = False;

---StartUsingToken---

// Matchmaking : allow substitutes
if (MM_IsMatchServer()) {
	MM_AllowSubstitutes(True);
}
***

// ---------------------------------- //
// Init start
// ---------------------------------- //
***InitTurn***
***
declare PoleTime = 0;
declare LastActionClanNb = 0;
declare SoundVariant = -1;
declare LastStatusTime = 0;
declare GoalCanBeCaptured = False;
declare AtkIsEliminated = False;
declare Win_TimeLimit = False;
declare Win_AtkEliminated = False;
declare Win_LastDefEliminated = False;
declare Win_Capture = False;
***

// ---------------------------------- //
// Turn start
// ---------------------------------- //
***StartTurn***
***
// ---------------------------------- //
// Wait players sycnhro
Mode::Synchro_DoBarrier();

SM::UnspawnAllPlayers();
foreach (Player in AllPlayers) {
	SetPlayerClan(Player, MM_GetRequestedClan(Player));
	if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
	else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
}
Score::RoundBegin();
InitUi();
UpdateMarkers();
AtkIsEliminated = False;
Win_TimeLimit = False;
Win_AtkEliminated = False;
Win_LastDefEliminated = False;
Win_Capture = False;
Message::CleanAllMessages();
Message::SetDefaultAllMessages("");

if (S_QuickMode) SleepMultiplier = 0.5;
else SleepMultiplier = 1.;

// ---------------------------------- //
// Manage the players order
WarmUp2::Clean();
if (GetMode() == C_ModeFree || MM_IsMatchServer()) WarmUp2::Fill();

// ---------------------------------- //
// Warm Up
if (GetMode() == C_ModeFree || MM_IsMatchServer()) {
	if (MM_IsMatchServer()) {
		NeedWarmUp = False;
	} else if (WarmUp2::GetPlayersNb("Clan1") < 1 || WarmUp2::GetPlayersNb("Clan2") < 1) {
		NeedWarmUp = True;
	}
} else {
	if (WarmUp2::GetPlayersNb("Clan1") < S_NbPlayersPerTeamMax || WarmUp2::GetPlayersNb("Clan2") < S_NbPlayersPerTeamMax) {
		NeedWarmUp = True;
	}
}

if ((NeedWarmUp || G_Override_NeedWarmUp) && !MM_IsMatchmakingServer()) {
	NeedWarmUp = False;
	MB_CurrentSection = "WarmUp";
	+++BeforeWarmUp+++
	WarmUp2();
	+++AfterWarmUp+++
	MB_CurrentSection = "StartTurn";
	
	G_Override_NeedWarmUp = False;
	MB_StopTurn = True;
	MB_SectionTurnNb -= 1;
	
	// ---------------------------------- //
	// Restart the script if the mode settings has changed
	if (GetMode() != OldMode) {
		OldMode = GetMode();
		MatchEndRequested = True;
		MB_Log("Changing mode > Restart match");
		declare Message = TextLib::Compose("$fff%1", _("Change mode and start a new match."));
		UIManager.UIAll.SendChat(Message);
		break;
	} 
	// ---------------------------------- //
	// Restart the match if the teams have changed
	else if (S_RestartMatchOnTeamChange) {
		declare NeedRestart = False;
		declare Order = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
		declare CurMapUsersIds = Ident[];
		for (I, 1, 2) {
			foreach (PlayerId in Order[I]) {
				if (Players.existskey(PlayerId)) CurMapUsersIds.add(Players[PlayerId].User.Id);
			}
		}
		
		if ((G_MapScores[1] > 0 || G_MapScores[2] > 0) && ClanScores[1] <= 0 && ClanScores[2] <= 0) {
			if (G_PrevMapUsersIds.count <= 0) G_PrevMapUsersIds = CurMapUsersIds;
			
			if (CurMapUsersIds.count != G_PrevMapUsersIds.count) {
				NeedRestart = True;
			} else {
				foreach (UserId in G_PrevMapUsersIds) {
					if (!CurMapUsersIds.exists(UserId)) {
						NeedRestart = True;
					}
				}
			}
		}
		G_PrevMapUsersIds = CurMapUsersIds;
		
		if (NeedRestart) {
			MatchEndRequested = True;
			MB_StopMatch = True;
			MB_Log("Teams changed > Restart the match");
			declare Message = TextLib::Compose("$fff%1", _("The teams have changed, the match will be restarted."));
			UIManager.UIAll.SendChat(Message);			
			break;
		} else {
			continue;
		}
	} else {
		continue;
	}
}
G_Override_NeedWarmUp = False;

// ---------------------------------- //
// IF WE PLAYED A WARM UP, THE TURN IS RESTARTED. THE FOLLOWING CODE IS NOT EXECUTED.
// ---------------------------------- //

// ---------------------------------- //
// Toss and determine who'll attack first on the map
if (GetMode() == C_ModeClassic && !MM_IsMatchmakingServer() && MB_SectionTurnNb <= 1) {
	declare DecisiveMap = False;
	if (G_MapScores[1] == S_MapWin - 1 && G_MapScores[2] == S_MapWin - 1) DecisiveMap = True;
	
	// Override the toss winner
	if (G_Override_TossWinner == 1 || G_Override_TossWinner == 2) {
		if (MB_SectionMapNb == 1) {
			if (TossWinner == -1) VoteClanNb = G_Override_TossWinner;
			else {
				TossWinner = G_Override_TossWinner;
				VoteClanNb = 3 - TossWinner;
			}
		} else {
			if (MB_SectionMapNb % 2 == 0) {
				VoteClanNb = 3 - G_Override_TossWinner;
			} else {
				VoteClanNb = G_Override_TossWinner;
			}
		}
		G_Override_TossWinner = -1;
	} else {
		// Play the toss
		if (MB_SectionMapNb == 1) {
			if (TossWinner == -1) VoteClanNb = Toss::Toss();
			else VoteClanNb = 3 - TossWinner;	///< The looser of the map selection toss
		}
	}
	 
	// Don't use toss but goal average on decisive map
	if (DecisiveMap && MB_SectionMapNb > 1) {
		declare GoalAverage = GetGoalAverageBestClan();
		if (GoalAverage == 1 || GoalAverage == 2) {
			VoteClanNb = GoalAverage;
		}
	}
	
	// Override the side selection
	if (G_Override_FirstAtkClan == 1 || G_Override_FirstAtkClan == 2) {
		G_AtkClan = G_Override_FirstAtkClan;
		G_DefClan = 3 - G_AtkClan;
		FirstAtk = G_Override_FirstAtkClan;
		G_Override_FirstAtkClan = -1;
	}
	// Vote for side
	else {
		declare SelectedSide = Toss::SelectSide(VoteClanNb);
		if (SelectedSide == 1) {
			G_AtkClan = VoteClanNb;
			G_DefClan = 3 - VoteClanNb;
		} else if (SelectedSide == 2) {
			G_AtkClan = 3 - VoteClanNb;
			G_DefClan = VoteClanNb;
		}
	}
	VoteClanNb = 3 - VoteClanNb;
}

// Override the first atk clan
if (G_Override_FirstAtkClan == 1 || G_Override_FirstAtkClan == 2) {
	FirstAtk = G_Override_FirstAtkClan;
	if (MB_SectionTurnNb % 2 == 0) {
		G_AtkClan = 3 - G_Override_FirstAtkClan;
		G_DefClan = G_Override_FirstAtkClan;
	} else {
		G_AtkClan = G_Override_FirstAtkClan;
		G_DefClan = 3 - G_Override_FirstAtkClan;
	}
	G_Override_FirstAtkClan = -1;
}


// ---------------------------------- //
// Play team presentation
if (MB_SectionTurnNb <= 1) {
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
	MM_PlayersPresentationSequence();
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
StartTime = -1;
EndTime = -1;

// ---------------------------------- //
// Get the next attacker
declare PreTurnEndTime = Now + MathLib::NearestInteger(2500 * SleepMultiplier);
declare NextAtkName = "";
declare Clan = "Clan1";
if (G_AtkClan == 2) Clan = "Clan2";
declare SlotNb = WarmUp2::GetSlotsNb(Clan);
declare I = 0;
while (True) {
	if (G_AtkSlot[G_AtkClan] > S_NbPlayersPerTeamMax) G_AtkSlot[G_AtkClan] = 1;
	
	declare PlayerId = WarmUp2::GetSlot(Clan, G_AtkSlot[G_AtkClan]);
	if (PlayerId != NullId && Players.existskey(PlayerId)) {
		NextAtkName = Players[PlayerId].Name;
		G_AtkPlayerId = PlayerId;
		declare netwrite Net_Elite_AtkLogin for Teams[0] = "";
		declare netwrite Net_Elite_AtkSponsors for Teams[0] = Text[];
		Net_Elite_AtkLogin = Players[PlayerId].Login;
		if (S_DisplaySponsors) Net_Elite_AtkSponsors = Clublink::GetTeamSponsors(G_AtkClan-1);
		else Net_Elite_AtkSponsors.clear();
		break;
	}
	
	G_AtkSlot[G_AtkClan] += 1;
	I += 1;
	if (I >= SlotNb) break;
}
ST2::SetFooterText(TextLib::Compose("%1 : %2", _("Attacker"), NextAtkName));

// ---------------------------------- //
// Attach the correct spawn screen layer and update the scores table
UpdateLayerScoresTable(C_SequencePlaying);
foreach (Player in Players) {
	declare PlayerClan = MM_GetRequestedClan(Player);
	if (PlayerClan == G_AtkClan) {
		Layers::Attach("SpawnScreenAttack", Player);
		Layers::Detach("SpawnScreenDefend", Player);
	} else if (PlayerClan == G_DefClan) {
		Layers::Attach("SpawnScreenDefend", Player);
		Layers::Detach("SpawnScreenAttack", Player);
	}
}

// ---------------------------------- //
// Play the pre turn sequence
declare TeamAtkName = "";
declare TeamDefName = "";
TeamAtkName = Teams[G_AtkClan - 1].ColorizedName;
TeamDefName = Teams[G_DefClan - 1].ColorizedName;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
UIManager.UIAll.BigMessageSoundVariant = 0;
UIManager.UIAll.StatusMessage = TextLib::Compose(
	_("$<%1$> attack - defense $<%2$>"), 
	TeamAtkName, 
	TeamDefName
);
UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> is attacking!"), NextAtkName);
---StartReplay---
---StartPreTurn---
while (Now <= PreTurnEndTime && !ServerShutdownRequested && !MatchEndRequested) {
	MM_Yield();
	ManageCommand();
	UpdateSpectators();
	ForceClublinkReload();
}
---EndPreTurn---
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Initialize variables
StartTime = Now + 3000;
EndTime = StartTime + S_TimeLimit * 1000;
PoleTime = (StartTime + (S_TimeLimit - S_TimePole) * 1000);
WinnerTurnClan = -1;
WinType = 0;
G_AtkElimPlayerId = NullId;

// ---------------------------------- //
// Init goals
foreach (Goal in Goals) {
	Goal.Gauge.Clan = G_DefClan;
	Goal.Gauge.Max = PoleTime - Now;
	Goal.Gauge.Speed = -1;
	Goal.Gauge.Value = Goal.Gauge.Max;
	Goal.Gauge.Captured = False;
}
// ---------------------------------- //
// Init checkpoints
foreach (Checkpoint in Checkpoints) {
	Checkpoint.Gauge.Clan = G_DefClan;
	Checkpoint.Gauge.Max = 1;
	Checkpoint.Gauge.Speed = 0;
	Checkpoint.Gauge.Value = 0;
	Checkpoint.Gauge.Captured = False;
}

// ---------------------------------- //
// Spawn players
SpawnThemAll(0);

// ---------------------------------- //
// Init UI
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
UIManager.UIAll.CountdownEndTime = PoleTime;
UpdateSpectators(True);

// ---------------------------------- //
// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
Clublink::SyncUpdate();

if (PrevClan1Color != Teams[0].ColorText || PrevClan2Color != Teams[1].ColorText) {
	PrevClan1Color = Teams[0].ColorText;
	PrevClan2Color = Teams[1].ColorText;
	Layers::Update("ScoresTable", CreateLayerScoresTable());
}
UpdateLayerScoresTable(C_SequencePlaying);
UpdateMarkers();
		
declare AtkPlayer <=> CSmPlayer;
if (Players.existskey(G_AtkPlayerId)) AtkPlayer <=> Players[G_AtkPlayerId];
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	XmlRpc.SendCallback("BeginTurn", Json::Enfold(Json::Merge([
		Json::Stringify("TurnNumber", MB_SectionTurnNb),
		TurnStringify(),
		Json::Stringify("AttackingClan", G_AtkClan),
		Json::Stringify("DefendingClan", G_DefClan),
		PlayerStringify("AttackingPlayer", AtkPlayer),
		PlayersStringify("DefendingPlayers", G_DefClan)
	])));
}

if (!TokenUsed) {
	---GetAndUseToken---
	TokenUsed = True;
}

// ---------------------------------- //
// Save the list of users playing on this map
declare Order = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
declare CurMapUsersIds = Ident[];
for (I, 1, 2) {
	foreach (PlayerId in Order[I]) {
		if (Players.existskey(PlayerId)) CurMapUsersIds.add(Players[PlayerId].User.Id);
	}
}
G_PrevMapUsersIds = CurMapUsersIds;

// ---------------------------------- //
// Save a back up to restore the game to this turn in case of a force warm up
Save_MatchDefElim		= G_MatchDefElim;
Save_MapDefElim			= G_MapDefElim;
Save_TieBreakDefElim	= G_TieBreakDefElim;
foreach (Score in Scores) {
	declare LaserLongest	for Score = 0.;
	declare LaserHit		for Score = 0;
	declare NbHit			for Score = 0;
	declare NbElimination	for Score = 0;
	declare NbBeHit			for Score = 0;
	declare DefRatio		for Score = 0.;
	declare LaserShot		for Score = 0;
	
	declare Save_LaserLongest	for Score = LaserLongest;
	declare Save_LaserHit		for Score = LaserHit;
	declare Save_NbHit			for Score = NbHit;
	declare Save_NbElimination	for Score = NbElimination;
	declare Save_NbBeHit		for Score = NbBeHit;
	declare Save_DefRatio		for Score = DefRatio;
	declare Save_LaserShot		for Score = LaserShot;
	
	Save_LaserLongest	= LaserLongest;
	Save_LaserHit		= LaserHit;
	Save_NbHit			= NbHit;
	Save_NbElimination	= NbElimination;
	Save_NbBeHit		= NbBeHit;
	Save_DefRatio		= DefRatio;
	Save_LaserShot		= LaserShot;
}
***

***Yield***
***
Message::Loop();
Clublink::Update();
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
declare DefElimintedNb = 0;
SM::UnspawnPlayersChangingClan();
ManageCommand();
ForceClublinkReload();

// ---------------------------------- //
// Pole management
---PoleManagement---

// ---------------------------------- //
// Validate events
---ValidateEvents---

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Standard event management
	
	// ---------------------------------- //
	// OnHit
	if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Win_TimeLimit || Win_Capture) {
			Discard(Event);
		} else if (Event.Shooter != Null && Event.Victim != Null) {
			if (Win_AtkEliminated) {
				if (Event.Victim.Id == G_AtkPlayerId) {
					---EventOnHit---
				} else {
					Discard(Event);
				}
			} else if (Win_LastDefEliminated) {
				if (Event.Victim.CurrentClan == G_DefClan) {
					---EventOnHit---
				} else {
					Discard(Event);
				}
			} else {
				---EventOnHit---
			}
		} else {
			Discard(Event);
		}
	}
	// ---------------------------------- //
	// OnArmorEmpty
	else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (Win_TimeLimit || Win_Capture) {
			Discard(Event);
		} else {
			if (Win_AtkEliminated) {
				if (Event.Victim.Id == G_AtkPlayerId) {
					---EventOnArmorEmpty---
				} else {
					Discard(Event);
				}
			} else if (Win_LastDefEliminated) {
				if (Event.Victim.CurrentClan == G_DefClan) {
					---EventOnArmorEmpty---
				} else {
					Discard(Event);
				}
			} else {
				---EventOnArmorEmpty---
			}
		}
	}
	// ---------------------------------- //
	// OnPlayerRequestRespawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		if (Win_TimeLimit || Win_Capture) {
			Discard(Event);
		} else {
			if (Win_AtkEliminated) {
				if (Event.Player.Id == G_AtkPlayerId) {
					---EventOnPlayerRequestRespawn---
				} else {
					Discard(Event);
				}
			} else if (Win_LastDefEliminated) {
				if (Event.Player.CurrentClan == G_DefClan) {
					---EventOnPlayerRequestRespawn---
				} else {
					Discard(Event);
				}
			} else {
				---EventOnPlayerRequestRespawn---
			}
		}
	}
	// ---------------------------------- //
	// OnCapture
	else if (Event.Type == CSmModeEvent::EType::OnCapture) {
		if (Win_TimeLimit || Win_AtkEliminated || Win_LastDefEliminated) {
			Discard(Event);
		} else {
			---EventOnCapture---
		}
	}
	// ---------------------------------- //
	// OnShoot
	else if (Event.Type == CSmModeEvent::EType::OnShoot) {
		---EventOnShoot---
	}
	// ---------------------------------- //
	// OnNearMiss
	else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
		---EventOnNearMiss---
	}
	// ---------------------------------- //
	// OnPlayerAdded
	else if (Event.Type == CSmModeEvent::EType::OnPlayerAdded) {
		---EventOnPlayerAdded---
	}
	// ---------------------------------- //
	// OnPlayerRemoved
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRemoved) {
		---EventOnPlayerRemoved---
	}
	// ---------------------------------- //
	// Other cases
	else {
		PassOn(Event);
	}
}

// ---------------------------------- //
// Update Spectators and messages
UpdateSpectators();
if (LastStatusTime > 0 && LastStatusTime + 3000 < Now) {
	UIManager.UIAll.StatusMessage = "";
	LastStatusTime = 0;
}

// ---------------------------------- //
// Victory/defeat conditions check
if (Now > StartTime)  {
	// ---------------------------------- //
	// Win by reaching time limit
	if (Now >= EndTime) {
		MB_Log("Win by timelimit");
		WinnerTurnClan = G_DefClan ;
		WinType = C_WinTimeLimit;
		UpgradeScore(G_DefClan, 1);
		+++RegisterStats+++
		MB_StopTurn = True;
		declare AtkPlayer <=> CSmPlayer;
		if (Players.existskey(G_AtkPlayerId)) {
			AtkPlayer <=> Players[G_AtkPlayerId];
			UnspawnPlayer(AtkPlayer);
		}
	}

	if (WinnerTurnClan == -1) {
		// ---------------------------------- //
		// Win by elimination of attacking player
		if ((ClansNbPlayersAlive[G_AtkClan] <= 0 && ClansNbPlayersAlive[G_DefClan] > 0)
			|| AtkIsEliminated
			|| !Players.existskey(G_AtkPlayerId)
			|| (Players.existskey(G_AtkPlayerId) && Players[G_AtkPlayerId].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
		) {
			MB_Log("Win by elimination of attack player");
			WinnerTurnClan = G_DefClan ;
			WinType = C_WinAttackEliminated;
			UpgradeScore(G_DefClan, 1);
			+++RegisterStats+++
			MB_StopTurn = True;
		} 
		// ---------------------------------- //
		// If the attacker is still alive
		else if (Players.existskey(G_AtkPlayerId)) {
			declare GoalCaptured = False;
			foreach (Goal in Goals) {
				if (Goal.Gauge.Captured && Goal.Gauge.Clan == G_AtkClan) GoalCaptured = True;
			}
			
			// ---------------------------------- //
			// Win by elimination of all defending players
			declare AllDefElim = ClansNbPlayersAlive[G_DefClan] <= 0;
			---AllDefElim---
			
			if (AllDefElim) {
				MB_Log("Win by elimination of all defense players");
				WinType = C_WinDefenseEliminated;
			}
			// ---------------------------------- //
			// Win by capturing the pole
			else if (GoalCaptured) {
				// Save the fastest capture time
				if (G_MatchBestCaptureTime[G_AtkClan] <= 0 || Now - StartTime < G_MatchBestCaptureTime[G_AtkClan]) {
					G_MatchBestCaptureTime[G_AtkClan] = Now - StartTime;
				}
				if (G_MapBestCaptureTime[G_AtkClan] <= 0 || Now - StartTime < G_MapBestCaptureTime[G_AtkClan]) {
					G_MapBestCaptureTime[G_AtkClan] = Now - StartTime;
				}
				MB_Log("Win by reaching pole");
				WinType = C_WinCapture;
			}
			
			if (WinType == C_WinCapture || WinType == C_WinDefenseEliminated) {
				UpgradeScore(G_AtkClan, 1);
				WinnerTurnClan = G_AtkClan;
				+++RegisterStats+++
				MB_StopTurn = True;
			}
		}
	}
}

// ---------------------------------- //
// Force a warm up
if (G_Override_NeedWarmUp) MB_StopTurn = True;
***

// ---------------------------------- //
// Turn end
// ---------------------------------- //
***EndTurn***
***
EndTime = Now;
UIManager.UIAll.CountdownEndTime = -1;
Score::RoundEnd();
UpdateHeader();
Message::SetDefaultAllMessages("");

+++EndTurnBegin+++

// ---------------------------------- //
// Save the current clan of each player in his score
foreach (Player in Players) {
	if (Player.Score == Null) continue;
	Player.Score.LadderClan = Player.CurrentClan;
}

// Display the "attacker capture the pole" message
if (WinType == C_WinCapture) {
	Message::SendBigMessage(_("Goal captured!"), 3000, 2, CUIConfig::EUISound::VictoryPoint, 0);
}

// Remove the gauge UI from the attacker
if (Players.existskey(G_AtkPlayerId)) {
	declare UI <=> UIManager.GetUI(Players[G_AtkPlayerId]);
	if (UI != Null) {
		UI.GaugeRatio = -1.;
		UI.GaugeMessage = "";
		UI.GaugeClan = 0;
	}
}
Elite_Sleep(1);

// ---------------------------------- //
// XmlRpc CallBack
declare AtkPlayer <=> CSmPlayer;
declare HeaderClanScores = Integer[Integer];
if (Players.existskey(G_AtkPlayerId)) AtkPlayer <=> Players[G_AtkPlayerId];
HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];

declare WinTypeString = "Unknown";
switch(WinType) {
	case C_WinTimeLimit: WinTypeString = "TimeLimit";
	case C_WinCapture: WinTypeString = "Capture";
	case C_WinAttackEliminated: WinTypeString = "AttackEliminated";
	case C_WinDefenseEliminated: WinTypeString = "DefenseEliminated";
}

if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	XmlRpc.SendCallback("EndTurn", Json::Enfold(Json::Merge([
		Json::Stringify("TurnNumber", MB_SectionTurnNb),
		TurnStringify(),
		Json::Stringify("AttackingClan", G_AtkClan),
		Json::Stringify("DefendingClan", G_DefClan),
		PlayerStringify("AttackingPlayer", AtkPlayer),
		Json::Stringify("TurnWinnerClan", WinnerTurnClan),
		Json::Stringify("WinType", WinTypeString),
		Json::Stringify("Clan1RoundScore", ClanScores[1]),
		Json::Stringify("Clan2RoundScore", ClanScores[2]),
		Json::Stringify("Clan1MapScore", HeaderClanScores[1]),
		Json::Stringify("Clan2MapScore", HeaderClanScores[2]),
		PlayersStringify("ScoresTable", 0, True)
	])));
}

// ---------------------------------- //
// Update UI
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.NoticesFilter_HideMapWarning = False;
UpdateLayerScoresTable(C_SequencePlaying);
+++EndTurnUIStart+++

// ---------------------------------- //
// Restart the script if the mode settings has changed
if (GetMode() != OldMode) {
	OldMode = GetMode();
	MatchEndRequested = True;
	MB_Log("Changing mode > Restart match");
	declare Message = TextLib::Compose("$fff%1", _("Change mode and start a new match."));
	UIManager.UIAll.SendChat(Message);
}

// ---------------------------------- //
// Skip the turn end sequence if a vote passed
if (MatchEndRequested) break;

// ---------------------------------- //
// Skip the turn end sequence if a warm up was requested
// And restore the turn to its previous state
if (G_Override_NeedWarmUp && WinType == 0) {
	MB_SectionTurnNb -= 1;
	
	G_MatchDefElim		= Save_MatchDefElim;
	G_MapDefElim		= Save_MapDefElim;
	G_TieBreakDefElim	= Save_TieBreakDefElim;
	foreach (Score in Scores) {
		declare LaserLongest	for Score = 0.;
		declare LaserHit		for Score = 0;
		declare NbHit			for Score = 0;
		declare NbElimination	for Score = 0;
		declare NbBeHit			for Score = 0;
		declare DefRatio		for Score = 0.;
		declare LaserShot		for Score = 0;
		
		declare Save_LaserLongest	for Score = LaserLongest;
		declare Save_LaserHit		for Score = LaserHit;
		declare Save_NbHit			for Score = NbHit;
		declare Save_NbElimination	for Score = NbElimination;
		declare Save_NbBeHit		for Score = NbBeHit;
		declare Save_DefRatio		for Score = DefRatio;
		declare Save_LaserShot		for Score = LaserShot;
		
		LaserLongest	= Save_LaserLongest;
		LaserHit		= Save_LaserHit;
		NbHit			= Save_NbHit;
		NbElimination	= Save_NbElimination;
		NbBeHit			= Save_NbBeHit;
		DefRatio		= Save_DefRatio;
		LaserShot		= Save_LaserShot;
	}
	
	foreach (Player in AllPlayers) {
		if (Player.Score != Null) {
			declare NbHit for Player.Score = 0;
			declare netwrite Net_LayerST_DefPoints for Player = 0;
			Net_LayerST_DefPoints = NbHit;
			ST2::SetColValue("DefPoints", Player.Score, TextLib::ToText(NbHit));
		}
	}
	
	+++ForceWarmUp+++
	UpdateLayerScoresTable(C_SequencePlaying);
	UpdateHeader();
	continue;
}

// ---------------------------------- //
// Show the capture gauge of the most (but not) captured pole if any
declare GaugeValue = 0;
declare MostActivatedGoal <=> CSmMapLandmark;
foreach (Goal in Goals) {
	Goal.Gauge.Speed = 0;

	if (Goal.Gauge.Clan == G_AtkClan && Goal.Gauge.Value > GaugeValue) {
		GaugeValue = Goal.Gauge.Value;
		MostActivatedGoal <=> Goal;
	}
}
if (MostActivatedGoal != Null
	&& MostActivatedGoal.Gauge.Value > 0 
	&& WinType != C_WinCapture
) {
	if (MostActivatedGoal.Gauge.ValueReal >= 1.) UIManager.UIAll.GaugeRatio = 0.99;
	else UIManager.UIAll.GaugeRatio = MostActivatedGoal.Gauge.ValueReal;
	UIManager.UIAll.GaugeClan = MostActivatedGoal.Gauge.Clan;
	UIManager.UIAll.GaugeMessage = "" ^ MathLib::FloorInteger(UIManager.UIAll.GaugeRatio*100) ^ "%";
}
Elite_Sleep(MathLib::NearestInteger(2000*SleepMultiplier));
StartTime = -1;
EndTime = -1;
SM::UnspawnAllPlayers();
Message::CleanAllMessages();

---EndReplay---

UIManager.UIAll.GaugeMessage = "";
UIManager.UIAll.GaugeRatio = -1000.;
UIManager.UIAll.GaugeClan = 0;

// ---------------------------------- //
// Check if we are in TieBreak
CheckTieBreak();

// ---------------------------------- //
// Check if a team wins the map
declare PointLimit = GetPointLimit();
declare GoalAverage = 3;
if (G_TieBreak) GoalAverage = GetGoalAverageBestClan();
declare TwoTeamsPlayedAtk = (MB_SectionTurnNb % 2 == 0);

// ---------------------------------- //
// If the end of the map is near, cancel any substitutes requests
if (MM_IsMatchServer()) {
	if (ClanScores[1] >= S_TurnWin - 2 || ClanScores[2] >= S_TurnWin - 2 || ClanScores[1] >= PointLimit - 2 || ClanScores[2] >= PointLimit - 2) {
		MM_AllowSubstitutes(False);
	} else {
		MM_AllowSubstitutes(True);
	}
}

if (
	ClanScores[1] >= S_TurnWin && ClanScores[1] > ClanScores[2] && ClanScores[1] - ClanScores[2] >= S_TurnGap
	|| ClanScores[2] >= S_TurnWin && ClanScores[2] > ClanScores[1] && ClanScores[2] - ClanScores[1] >= S_TurnGap
	|| ClanScores[1] >= PointLimit && ClanScores[1] > ClanScores[2]
	|| ClanScores[2] >= PointLimit && ClanScores[2] > ClanScores[1]
	|| (MM_IsMatchServer() && (ClansNbPlayers[1] <= 0 || ClansNbPlayers[2] <= 0))
) {
	// ---------------------------------- //
	// Find the winner of the map
	// ---------------------------------- //
	// Clan 1 withdraw
	if (MM_IsMatchServer() && ClansNbPlayers[1] <= 0) {
		WinnerMapClan = 2;
		WinByForfeit = True;
	} 
	// ---------------------------------- //
	// Clan 2 withdraw
	else if (MM_IsMatchServer() && ClansNbPlayers[2] <= 0) {
		WinnerMapClan = 1;
		WinByForfeit = True;
	}
	// ---------------------------------- //
	// Clan 1 wins the map with the best score
	else if ((ClanScores[1] > ClanScores[2])) {
		WinnerMapClan = 1;
	}
	// ---------------------------------- //
	// Clan 2 wins the map with the best score
	else if ((ClanScores[2] > ClanScores[1]))  {
		WinnerMapClan = 2;
	}
	WinnerSubmatchClan = WinnerMapClan;
	
	if (WinnerMapClan != -1) MB_StopMap = True;
}

// ---------------------------------- //
// Play turn end sequence
if (!MB_StopSubmatch && !MB_StopMap) {
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	if (WinnerTurnClan == G_AtkClan) UIManager.UIAll.BigMessageSoundVariant = 1;
	else if (WinnerTurnClan == G_DefClan) UIManager.UIAll.BigMessageSoundVariant = 0;
	
	declare EliminatorName = "";
	if (G_AtkElimPlayerId != NullId && Players.existskey(G_AtkElimPlayerId)) {
		EliminatorName = "$<"^Players[G_AtkElimPlayerId].Name^"$>";
	}
	
	if (WinType == C_WinTimeLimit) UIManager.UIAll.StatusMessage = _("Time limit reached.");
	else if (WinType == C_WinCapture) UIManager.UIAll.StatusMessage = _("Goal captured.");
	else if (WinType == C_WinAttackEliminated && EliminatorName == "") UIManager.UIAll.StatusMessage = _("Attacker eliminated.");
	else if (WinType == C_WinAttackEliminated && EliminatorName != "") {
		UIManager.UIAll.StatusMessage = TextLib::Compose(_("$<%1$> eliminated the attacker."), EliminatorName);
	}
	else if (WinType == C_WinDefenseEliminated) UIManager.UIAll.StatusMessage = _("All defenders eliminated.");
	
	declare Pseudo = _("Attacker");
	if (Players.existskey(G_AtkPlayerId)) Pseudo = Players[G_AtkPlayerId].Name;
	
	declare DefTeamName = Teams[G_DefClan - 1].ColorizedName;
	
	if (WinnerTurnClan == G_AtkClan) 
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the turn!"), Pseudo);
	else if (WinnerTurnClan == G_DefClan) 
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the turn!"), DefTeamName);
		
	if (!S_QuickMode) UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	Elite_Sleep(MathLib::NearestInteger(3000*SleepMultiplier));
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}

// ---------------------------------- //
// Stop turn end sequence
+++EndTurnUIStop+++
SM::UnspawnAllPlayers();
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Select the next atk slot
G_AtkSlot[G_AtkClan] += 1;
if (G_AtkSlot[G_AtkClan] > S_NbPlayersPerTeamMax) G_AtkSlot[G_AtkClan] = 1;
// ---------------------------------- //
// Team exchange role for the next turn
G_AtkClan = G_DefClan;
G_DefClan = 3 - G_AtkClan;
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***EndRound***
***
// ---------------------------------- //
// Skip the round end sequence if a vote passed
if (MatchEndRequested) break;
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMap***
***
---StopUsingToken---
// Override the first atk clan if a #Command was voted before the end of the map
if (G_Override_FirstAtkClan == 1 || G_Override_FirstAtkClan == 2) {
	FirstAtk = G_Override_FirstAtkClan;
	if (MB_SectionTurnNb % 2 == 0) {
		G_AtkClan = 3 - G_Override_FirstAtkClan;
		G_DefClan = G_Override_FirstAtkClan;
	} else {
		G_AtkClan = G_Override_FirstAtkClan;
		G_DefClan = 3 - G_Override_FirstAtkClan;
	}
	G_Override_FirstAtkClan = -1;
}

declare HeaderClanScores = Integer[Integer];
HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	XmlRpc.SendCallback("EndMap", Json::Enfold(Json::Merge([
		Json::Stringify("MapNumber", MB_SectionMapNb),
		Json::Stringify("MapWinnerClan", WinnerMapClan),
		Json::Stringify("Clan1MapScore", HeaderClanScores[1]),
		Json::Stringify("Clan2MapScore", HeaderClanScores[2]),
		PlayersStringify("ScoresTable", 0)
	])));
}

// ---------------------------------- //
// Play map end sequence
//UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

// ---------------------------------- //
// Give Ladder Points
---LadderPoints---

// ---------------------------------- //
// Find the Master
---FindMaster---

declare Text Message = "";
// ---------------------------------- //
// Display the winning message if there is one
if (WinnerMapClan != -1) {
	declare Message = "";
	if (WinnerMapClan == 3) {
		G_MapScores[1] += 1;
		G_MapScores[2] += 1;
		UIManager.UIAll.StatusMessage = _("Points limit reached.");
		Message = _("|Match|Draw");
	} else {
		G_MapScores[WinnerMapClan] += 1;
		declare WinnerTeamName = Teams[WinnerMapClan - 1].ColorizedName;
		Message = TextLib::Compose(_("$<%1$> wins the map!"), WinnerTeamName);
		if (WinByForfeit) UIManager.UIAll.StatusMessage = _("Win by forfeit.");
		MB_Log("""Clan {{{WinnerMapClan}}} wins the Map {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	}
	
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = Message;
	if (UIManager.UIAll.StatusMessage == "")
		UIManager.UIAll.StatusMessage = "$<"^Teams[0].ColorizedName^"$> "^ClanScores[1]^" - "^ClanScores[2]^" $<"^Teams[1].ColorizedName^"$>";
	UpdateHeader();
	Elite_Sleep(MathLib::NearestInteger(500*SleepMultiplier));
	+++EndSequenceStart+++
	Elite_Sleep(MathLib::NearestInteger(1500*SleepMultiplier));
	UpdateLayerScoresTable(C_SequencePodium);
	Elite_Sleep(MathLib::NearestInteger(6000*SleepMultiplier));
}
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.BigMessage = "";
Message = "";

// ---------------------------------- //
// Cancel the result of the map if it was skipped
if (MatchEndRequested) {
	+++EndSequenceEnd+++
	
	FirstAtk = G_AtkClan;
	VoteClanNb = 3 - VoteClanNb;
	MapSkipped = True;
	
	// Ignore points on this map for goal average
	G_MatchAtkPoints[1] -= G_MapAtkPoints[1];
	G_MatchAtkPoints[2] -= G_MapAtkPoints[2];
	G_MatchDefElim[1] -= G_MapDefElim[1];
	G_MatchDefElim[2] -= G_MapDefElim[2];
	G_MatchBestCaptureTime[1] -= G_MapBestCaptureTime[1];
	G_MatchBestCaptureTime[2] -= G_MapBestCaptureTime[2];
	G_MatchPoints[1] -= ClanScores[1];
	G_MatchPoints[2] -= ClanScores[2];
	
	MB_SectionMapNb -= 1;
	
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = _("Map skipped, going to the next.");
	Elite_Sleep(1500);
	UIManager.UIAll.BigMessage = "";
	Mode::UnloadMap();
	
	MB_MapRestarted = False;
	
	continue;
}

// ---------------------------------- //
// Find the team who won the match

// ---------------------------------- //
// Draw
if (G_MapScores[1] == G_MapScores[2] && G_MapScores[1] >= S_MapWin) {
	Message = _("|Match|Draw");
	MB_Log("""Draw Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 0;
	MB_StopMatch = True;
}
// ---------------------------------- //
// Clan 1 wins with best score
else if (G_MapScores[1] >= S_MapWin) {
	Message = TextLib::Compose(_("$<%1$> wins the match!"), Teams[0].ColorizedName);
	MB_Log("""Clan 1 wins the Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 1;
	MB_StopMatch = True;
} 
// ---------------------------------- //
// Clan 2 wins with best score
else if (G_MapScores[2] >= S_MapWin) {
	Message = TextLib::Compose(_("$<%1$> wins the match!"), Teams[1].ColorizedName);
	MB_Log("""Clan 2 wins the Match {{{G_MapScores[1]}}}-{{{G_MapScores[2]}}}""");
	WinnerMatchClan = 2;
	MB_StopMatch = True;
} 
// ---------------------------------- //
// Matchmaking request match end or forfeit 
else if (MM_RestartMatchmaking || WinByForfeit) {
	MB_StopMatch = True;
}
// ---------------------------------- //
// No one wins, continue the match
else {
	MB_StopMatch = False;
}

// ---------------------------------- //
// Display the winning message if there is one
if(Message != "") {
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = Message;
	UIManager.UIAll.StatusMessage = "$<"^Teams[0].ColorizedName^"$> "^G_MapScores[1]^" - "^G_MapScores[2]^" $<"^Teams[1].ColorizedName^"$>";
	UpdateHeader();
	Elite_Sleep(3000);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
	Elite_Sleep(8000);
}

+++EndSequenceEnd+++

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.BigMessage = "";

if (MM_IsMatchServer()) {
	if (MB_StopMatch) {
		if (RematchNb < S_MatchmakingRematchNbMax) {
			IsRematch = MM_VoteForRematch();
			RematchNb += 1;
		}
		
		if (!IsRematch) {
			RematchNb = 0;
			MM_MatchEnd(MasterLogin);
			MM_MatchToLobby();
		} else {
			MM_VoteForNextMap(False);
		}
	} else {
		MM_VoteForNextMap(False);
	}
}
***

// ---------------------------------- //
// Match end
// ---------------------------------- //
***EndMatch***
***
declare HeaderClanScores = Integer[Integer];
HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	XmlRpc.SendCallback("EndMatch", Json::Enfold(Json::Merge([
		Json::Stringify("MatchNumber", MB_SectionMatchNb),
		Json::Stringify("MatchWinnerClan", WinnerMatchClan),
		Json::Stringify("Clan1MapScore", HeaderClanScores[1]),
		Json::Stringify("Clan2MapScore", HeaderClanScores[2])
	])));
}
***

***EndServer***
***
WarmUp2::Unload();
// Destroy Layers
Layers::Destroy("ScoresTable");
Layers::Destroy("SpawnScreenAttack");
Layers::Destroy("SpawnScreenDefend");
Layers::Clean();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the current mode of the script
 *	0 -> classic mode
 *	1 -> free mode
 *
 *	@return		The current mode of the script
 */
Integer GetMode() {
	declare Mode = S_Mode;
	if (Mode != C_ModeClassic && Mode != C_ModeFree) Mode = C_ModeClassic;
	return Mode;
}

// ---------------------------------- //
/// Check if the clublinks must be reloaded
Void ForceClublinkReload() {
	if (!G_Override_ForceClublinkReload) return;
	G_Override_ForceClublinkReload = False;
	
	Clublink::ResetAll();
	Clublink::DefineTeamAuto(True);
}

// ---------------------------------- //
/// Get the right point limit for the map
Integer GetPointLimit() {
	// Decider map point limit
	if (G_MapScores[1] == S_MapWin - 1 && G_MapScores[2] == S_MapWin - 1) return S_DeciderTurnLimit;
	// Standard point limit
	return S_TurnLimit;
}

// ---------------------------------- //
/// Initialize the color of the spawns, poles and other colored elements
Void InitBasesColor() {
	foreach (Base in MapBases) {
		Base.Clan = G_DefClan;
		Base.IsActive = True;
	}
	
	// Get def and atk spawn
	declare DefSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnDefense", 0);
	declare AtkSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnAttack", 0);
	
	// Color the bases
	if (DefSpawn.Base != AtkSpawn.Base && DefSpawn.Base != Null && AtkSpawn.Base != Null) {
		AtkSpawn.Base.Clan = G_AtkClan;
		AtkSpawn.Base.IsActive = True;
	}
}

// ---------------------------------- //
/// Save all the scores locally on the server
Void SaveScores() {
	
}

// ---------------------------------- //
/// Restore all the scores from the previous save
Void RestoreScores() {
	
}

// ---------------------------------- //
/** Spawns all the players.
 * 
 * @param _Phase		0 playing time, 1 warmup KotM, 2 warmup classic/free, 3 waiting time 
 */
Void SpawnThemAll(Integer _Phase) {
	// Get def and atk spawn
	declare DefSpawn <=> Map::GetPlayerSpawn("SpawnDefense", 0);
	declare AtkSpawn <=> Map::GetPlayerSpawn("SpawnAttack", 0);
	
	// WarmUp classic/free || Waiting time
	if (_Phase == 2 || _Phase == 3) {
		foreach (Player in Players) {	
			declare WarmUpSide for Player = True;
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
			
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, C_WURocketAmmoMax);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_WULaserAmmoMax);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			Player.ArmorMax	= C_AtkArmorMax;
			if (WarmUpSide) {
				Player.AmmoGain	= 1. * C_WULaserAmmoGain;
				Player.StaminaMax = 1.;
				Player.StaminaGain = 1.;
				
				SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
				SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, AtkSpawn, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			} else {
				Player.AmmoGain	= 1. * C_WURocketAmmoGain;
				Player.StaminaMax = 1. * C_DefStaminaMaxMultiplier;
				Player.StaminaGain = 1. * C_DefStaminaMaxMultiplier;
				SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
				SM::SpawnPlayer(Player, MM_GetRequestedClan(Player), Player.ArmorMax, DefSpawn, Now);
				SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, C_WUNucleusAmmoMax);
			}
			Player.IsHighlighted = True;
			WarmUpSide = !WarmUpSide;
		}
	} 
	// Playing time
	else {
		declare MaxDef = S_NbPlayersPerTeamMax;
		declare MaxAtk = 1;
		
		declare DefSpawned = 0;
		declare AtkSpawned = 0;
		
		declare OrderDef = Ident[Integer];
		declare OrderAtk = Ident[Integer];
		if (G_AtkClan == 1) {
			OrderDef = WarmUp2::GetGroup("Clan2");
			OrderAtk = WarmUp2::GetGroup("Clan1");
		} else if (G_AtkClan == 2) {
			OrderDef = WarmUp2::GetGroup("Clan1");
			OrderAtk = WarmUp2::GetGroup("Clan2");
		}
		
		// Spawn defenders
		foreach (Slot => PlayerId in OrderDef) {
			---SpawnDef---
		}
		
		// Spawn attackers
		foreach (Slot => PlayerId in OrderAtk) {
			---SpawnAtk---
		}
	} 	
	
	InitBasesColor();
}

// ---------------------------------- //
/** Update the given clan score.
 *
 * @param iClan  the clan the games needs to upgrade the score.
 * @param iPlus	 how many points the Clan gets.
 */
Void UpgradeScore(Integer _iClan, Integer _iPlus) {
	if (_iClan == 1) {
		ClanScores[1] += _iPlus;
		G_MatchPoints[1] += _iPlus;
		if (_iClan == G_AtkClan) {
			G_MatchAtkPoints[1] += 1;
			G_MapAtkPoints[1] += 1;
			if (Players.existskey(G_AtkPlayerId)) {
				Score::AddPoints(Players[G_AtkPlayerId], 1);
				declare netwrite Net_LayerST_AtkPoints for Players[G_AtkPlayerId] = 0;
				Net_LayerST_AtkPoints += 1;
				ST2::SetColValue("AtkPoints", Players[G_AtkPlayerId].Score, TextLib::ToText(Net_LayerST_AtkPoints));
			}
		}
	} else {
		ClanScores[2] += _iPlus;
		G_MatchPoints[2] += _iPlus;
		if (_iClan == G_AtkClan) {
			G_MatchAtkPoints[2] += 1;
			G_MapAtkPoints[2] += 1;
			if (Players.existskey(G_AtkPlayerId)) {
				Score::AddPoints(Players[G_AtkPlayerId], 1);
				declare netwrite Net_LayerST_AtkPoints for Players[G_AtkPlayerId] = 0;
				Net_LayerST_AtkPoints += 1;
				ST2::SetColValue("AtkPoints", Players[G_AtkPlayerId].Score, TextLib::ToText(Net_LayerST_AtkPoints));
			}
		}
	}
}

// ---------------------------------- //
/**	Get the clan with the best goal average since the beginning of the match
 *
 *	@return		1 for clan 1, 2 for clan 2, 3 for draw
 */
Integer GetGoalAverageBestClan() {
	// Most points
	if (G_MatchPoints[1] != G_MatchPoints[2]) {
		MB_Log("Goal average - Most Points - "^Teams[0].Name^" "^G_MatchPoints[1]^" - "^G_MatchPoints[2]^" "^Teams[1].Name);
		if (G_MatchPoints[1] > G_MatchPoints[2]) return 1;
		else return 2;
	}
	// Most def elimination
	else if (G_TieBreakDefElim[1] != G_TieBreakDefElim[2]) {
		MB_Log("Goal average - Most defenders elimination - "^Teams[0].Name^" "^G_TieBreakDefElim[1]^" - "^G_TieBreakDefElim[2]^" "^Teams[1].Name);
		if (G_TieBreakDefElim[1] > G_TieBreakDefElim[2]) return 1;
		else return 2;
	}
	
	return 3;
}

// ---------------------------------- //
/** Play a sound
 *
 * @param _Sound	The sound to play
 * @param _Variant	The variant to play
 */
Void PlaySound(CUIConfig::EUISound _Sound, Integer _Variant) {
	UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, _Sound, _Variant);
}

// ---------------------------------- //
/** Get the overview camera direction.
 *
 * @return	The direction of the camera
 */
Vec3 GetOverviewCamDirection() {
	declare FirstGoal <=> CSmMapLandmark;
	foreach (Goal in MapLandmarks_Gauge) {
		if (Goal.Tag == "Goal A") {
			FirstGoal <=> Goal;
			break;
		}
	}
	
	// Compatibility with old MapType
	if (FirstGoal == Null) FirstGoal <=> Map::GetLandmarkGauge("Goal", 0);
	if (FirstGoal == Null) { declare Vec3 NoPosition; return NoPosition; }
	
	declare AtkSpawn <=> Map::GetLandmarkPlayerSpawn("SpawnAttack", 0);
	return AtkSpawn.Position - FirstGoal.Position;
}

// ---------------------------------- //
/** Helper for the DisplayHitFunction
 *
 * @param	_Player		The player who'll receive the notice
 * @param	_Message	The message for the notice
 */
Void NoticeHitDistance(CSmPlayer _Player, Text _Message) {
	declare UI <=> UIManager.GetUI(_Player);
	Message::SendBigMessage(_Player, _Message, 2000, 2);
}

// ---------------------------------- //
/** Display the distance between the shooter and the victim
 *
 *	@param	_Shooter		The shooter
 *	@param	_Victim			The Victim
 *	@param	_ShooterOnly	Display the distance hit message to the shooter only
 */
Void DisplayHitDistance(CSmPlayer _Shooter, CSmPlayer _Victim, Boolean _ShooterOnly) {
	if (_Shooter == Null || _Victim == Null) return;
	
	declare Distance = MathLib::Distance(_Shooter.Position, _Victim.Position);
	Distance = MathLib::NearestInteger(Distance*10.0)/10.0;
	declare DistanceMessage = TextLib::Compose(_("%1m hit!"), TextLib::SubString(TextLib::ToText(Distance), 0, 5));
	if (_ShooterOnly) {
		NoticeHitDistance(_Shooter, DistanceMessage);
	} else {
		foreach (Player in Players) {
			if (Player.CurrentClan == G_AtkClan) {
				NoticeHitDistance(Player, DistanceMessage);
			}
		}
		foreach (Spectator in Spectators) {
			NoticeHitDistance(Spectator, DistanceMessage);
		}
		if (Distance > G_LongestRailDistance) {
			G_LongestRailName = _Shooter.Name;
			G_LongestRailDistance = Distance;
		}
	}
}

// ---------------------------------- //
/** Get the objective manialink string.
 * 
 * @param _Objective		The objective to show on the spawwn screen
 *
 * @return		The manialink string
 */
Text UpdateLayerSpawnScreen(Text _Objective) {
	declare Text Objective = TextLib::MLEncode(_Objective);
	
	return """
<frame posn="0 55 0" id="FrameObjective">
	<quad posn="0 0 1" sizen="120 16" halign="center" valign="center" style="Bgs1InRace" substyle="BgList" />
	<label posn="0 2 2" sizen="116 14" halign="center" scale="3" valign="center" text="{{{ Objective }}}"/>
</frame>
	""";
}

// ---------------------------------- //
/** Generate players list for the score table
 *
 *	@param	_Mode	The mode creating the list: 1 = Elite, 2 = Heroes
 *	@param	_Nb		Number of players in the list
 *	@param	_Scale	Width scale
 *
 *	@return	The players list Text
 */
Text CreatePlayersListBig(Integer _Mode, Integer _Nb, Real _Scale) {
	---CreatePlayersListBig---
}

// ---------------------------------- //
/** Create the score table manialink string.
 * 
 * @return		The manialink string
 */
Text CreateLayerScoresTable() {
	---CreateLayerScoresTable---
}

// ---------------------------------- //
/** Update the score table manialink string.
 *
 *	@param	_Mode	Type of display for the scores table (warm-up, playing, ...)
 * 
 *	@return		The manialink string
 */
Void UpdateLayerScoresTable(Integer _Mode) {
	---UpdateLayerScoresTable---
}

// ---------------------------------- //
/// Update the score summary header.
Void UpdateHeader() {
	declare CSmPlayer Player1 <=> Null;
	declare CSmPlayer Player2 <=> Null;
	declare HeaderClanScores = Integer[Integer];
	
	HeaderClanScores = [1 => G_MapScores[1], 2 => G_MapScores[2]];

	// Find a captain for each clan
	foreach (Player in Players) {
		if (Player.CurrentClan == 1) {
			Player1 <=> Player;
		} else if (Player.CurrentClan == 2) {
			Player2 <=> Player;
		}
	}
	
	UIManager.UIAll.OverlayScoreSummary = True;
	if (Player1 != Null) {
		UIManager.UIAll.ScoreSummary_Player1 = Player1.Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[1];
		UIManager.UIAll.ScoreSummary_MatchPoints1 = HeaderClanScores[1];
	} else {
		UIManager.UIAll.ScoreSummary_Player1 = NullId;
		UIManager.UIAll.ScoreSummary_Points1 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints1 = 0;
	}

	if (Player2 != Null) {
		UIManager.UIAll.ScoreSummary_Player2 = Player2.Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[2];
		UIManager.UIAll.ScoreSummary_MatchPoints2 = HeaderClanScores[2];
	} else {
		UIManager.UIAll.ScoreSummary_Player2 = NullId;
		UIManager.UIAll.ScoreSummary_Points2 = 0;
		UIManager.UIAll.ScoreSummary_MatchPoints2 = 0;
	}
	
	declare netwrite Clan1MapPoints for XmlRpc = 0;
	declare netwrite Clan1MatchPoints for XmlRpc = 0;
	declare netwrite Clan2MapPoints for XmlRpc = 0;
	declare netwrite Clan2MatchPoints for XmlRpc = 0;
	Clan1MapPoints = ClanScores[1];
	Clan1MatchPoints = HeaderClanScores[1];
	Clan2MapPoints = ClanScores[2];
	Clan2MatchPoints = HeaderClanScores[2];
}

// ---------------------------------- //
/// Init the UI state.
Void InitUi() {
	SM::SetupDefaultVisibility();
	UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Always;
	UIManager.UIAll.TeamLabelsShowGauges = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedHidden;
	UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
	UpdateHeader();
}

// ---------------------------------- //
/** Update the spectators
 *
 *	@param	_Forced		Force the update
 */
Void UpdateSpectators(Boolean _Forced) {
	if (!_Forced && G_LastSpecUpdate + C_SpecRefreshInterval > Now) return;
	G_LastSpecUpdate = Now;
	UIManager.UIAll.SpectatorCamAutoLongitude = MathLib::Atan2(-G_MapSpecCamDirection.X, -G_MapSpecCamDirection.Z);
	UIManager.UIAll.SpectatorCamAutoLatitude = 0.5;
	
	UIManager.UIAll.SpectatorAutoTarget = G_AtkPlayerId;
	
	declare SpecDefId = NullId;
	foreach (Player in Players) {
		if (Player.CurrentClan == G_DefClan && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			SpecDefId = Player.Id;
		}
	}
	
	foreach (Player in Players) {		
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		// Can select defender to spec
		if (Player.CurrentClan != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = Player.CurrentClan;
		} else if (MM_GetRequestedClan(Player) != 0) {
			UI.SpectatorForceCameraType = 1;
			UI.SpectatorForcedClan = MM_GetRequestedClan(Player);
		} else {
			UI.SpectatorForceCameraType = -1;
			UI.SpectatorForcedClan = -1;
		}
		
		declare PrevSpectatorForcedClan for UI = -1;
		PrevSpectatorForcedClan = UI.SpectatorForcedClan;
	}
	
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
			
		if (UI.SpectatorForceCameraType >= 0 || UI.SpectatorForcedClan >= 0) {
			UI.SpectatorForceCameraType = -2;
			UI.SpectatorForcedClan = -2;
			
			declare PrevSpectatorForcedClan for UI = -1;
			if (PrevSpectatorForcedClan != UI.SpectatorForcedClan) {
				PrevSpectatorForcedClan = UI.SpectatorForcedClan;
				UIManager.UIAll.SendChat(TextLib::Compose("$<%1$> goes into spectator mode", Spectator.Name));
			}
		}
	}
}
Void UpdateSpectators() {
	UpdateSpectators(False);
}

// ---------------------------------- //
/// Check if we are in TieBreak
Void CheckTieBreak() {
	/*if (Clan1Score + Clan2Score >= GetPointLimit() * 2) {
		G_TieBreak = True;
	} else {
		G_TieBreak = False;
	}*/
	G_TieBreak = False;
}

// ---------------------------------- //
/// Manage #Command
Void ManageCommand() {
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnCommand) {
			switch (Event.CommandName) {
				// ---------------------------------- //
				case "Command_MatchPointsClan1": {
					if (Event.CommandValueInteger < 0) G_MapScores[1] = 0;
					else G_MapScores[1] = Event.CommandValueInteger;
					MB_SectionMapNb = G_MapScores[1] + G_MapScores[2] + 1;
					
					UpdateHeader();
					CheckTieBreak();
				}
				// ---------------------------------- //
				case "Command_MatchPointsClan2": {
					if (Event.CommandValueInteger < 0) G_MapScores[2] = 0;
					else G_MapScores[2] = Event.CommandValueInteger;
					MB_SectionMapNb = G_MapScores[1] + G_MapScores[2] + 1;
					
					UpdateHeader();
					CheckTieBreak();
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan1": {
					G_MatchPoints[1] -= ClanScores[1];
					if (Event.CommandValueInteger < 0) ClanScores[1] = 0;
					else ClanScores[1] = Event.CommandValueInteger;
					G_MatchPoints[1] += ClanScores[1];
					MB_SectionTurnNb = ClanScores[1] + ClanScores[2] + 1;
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
					UpdateHeader();
					CheckTieBreak();
				}
				// ---------------------------------- //
				case "Command_CurrentMapPointsClan2": {
					G_MatchPoints[2] -= ClanScores[2];
					if (Event.CommandValueInteger < 0) ClanScores[2] = 0;
					else ClanScores[2] = Event.CommandValueInteger;
					G_MatchPoints[2] += ClanScores[2];
					MB_SectionTurnNb = ClanScores[1] + ClanScores[2] + 1;
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
					UpdateHeader();
					CheckTieBreak();
				}
				// ---------------------------------- //
				case "Command_PreviousMapsPointsClan1": {
					if (Event.CommandValueInteger < 0) G_MatchPoints[1] = 0;
					else G_MatchPoints[1] = Event.CommandValueInteger;
					G_MatchPoints[1] += ClanScores[1];
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
				}
				// ---------------------------------- //
				case "Command_PreviousMapsPointsClan2": {
					if (Event.CommandValueInteger < 0) G_MatchPoints[2] = 0;
					else G_MatchPoints[2] = Event.CommandValueInteger;
					G_MatchPoints[2] += ClanScores[2];
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
				}
				// ---------------------------------- //
				case "Command_TieBreakDefElimClan1": {
					if (Event.CommandValueInteger < 0) G_TieBreakDefElim[1] = 0;
					else G_TieBreakDefElim[1] = Event.CommandValueInteger;
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
				}
				// ---------------------------------- //
				case "Command_TieBreakDefElimClan2": {
					if (Event.CommandValueInteger < 0) G_TieBreakDefElim[2] = 0;
					else G_TieBreakDefElim[2] = Event.CommandValueInteger;
					
					if (MB_CurrentSection == "WarmUp") UpdateLayerScoresTable(C_SequenceWarmUp);
					else UpdateLayerScoresTable(C_SequencePlaying);
				}
				// ---------------------------------- //
				case "Command_ForceFirstAtkClan": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_FirstAtkClan = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceTossWinner": {
					if (Event.CommandValueInteger == 1 || Event.CommandValueInteger == 2) G_Override_TossWinner = Event.CommandValueInteger;
				}
				// ---------------------------------- //
				case "Command_ForceWarmUp": {
					if (Event.CommandValueBoolean) {
						G_Override_NeedWarmUp = True;
					}
				}
				// ---------------------------------- //
				case "Command_ForceClublinkReload": {
					if (Event.CommandValueBoolean) {
						G_Override_ForceClublinkReload = True;
					}
				}
			}
		}
	}
}

// ---------------------------------- //
/** Custom sleep function for Elite
 *
 *	@param	_Duration	The time to spend sleeping in ms
 */
Void Elite_Sleep(Integer _Duration) {
	declare End = Now + _Duration;
	while(Now < End) {
		MM_Yield();
		ManageCommand();
		ForceClublinkReload();
	}
}

// ---------------------------------- //
/// Prepare the match
Void PrepareMatch() {
	WarmUp2::Begin();
	WarmUp2::Detach();
	
	declare TimeOut = 5000;
	declare PrevClansNbPlayers = [1 => 0, 2 => 0];
	StartTime = Now;
	UIManager.UIAll.CountdownEndTime = -1;
	
	// ---------------------------------- //
	// Sort players by ladder points
	declare PlayersSort = [1 => Real[Ident], 2 => Real[Ident]];
	foreach (Player in Players) {
		SetPlayerClan(Player, MM_GetRequestedClan(Player));
		if (!PlayersSort.existskey(Player.CurrentClan)) continue;
		PlayersSort[Player.CurrentClan][Player.Id] = -Player.User.LadderPoints;
	}
	
	PlayersSort[1] = PlayersSort[1].sort();
	PlayersSort[2] = PlayersSort[2].sort();
	
	for (I, 1, 2) {
		declare J = 0;
		declare Clan = "";
		if (I == 1) Clan = "Clan1";
		else Clan = "Clan2";
		
		foreach (PlayerId => Sorting in PlayersSort[I]) {
			if (!Players.existskey(PlayerId)) continue;
			J += 1;
			WarmUp2::SetPlayerGroup(Players[PlayerId], Clan);
			WarmUp2::SetPlayerSlot(Players[PlayerId], J, True);
		}
	}
	
	WarmUp2::Clean();
	WarmUp2::Fill();
	UpdateLayerScoresTable(C_SequenceWarmUp);
	
	
	declare AllPlayersAreAllies = [1 => False, 2 => False];
	declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	// ---------------------------------- //
	// Use matchmaking order when available
	if (MM_IsUniversalServer()) {
		foreach (Player in Players) {
			declare Slot = MM_GetRequestedSlot(Player);
			declare Clan = MM_GetRequestedClan(Player);
			declare Group = "";
			if (Clan == 1) Group = "Clan1";
			else if (Clan == 2) Group = "Clan2";
			
			if (Group != "" && Slot >= 0) {
				WarmUp2::SetPlayerGroup(Player, Group);
				WarmUp2::SetPlayerSlot(Player, Slot+1, True);
			}
		}
	} 
	// ---------------------------------- //
	// Check if the players are all allies
	else {
		for (I, 1, 2) {
			declare J = 1;
			declare AlliesNb = 0;
			declare TestedNb = 0;
			foreach (Slot => Id in ClansOrders[I]) {
				if (Players.existskey(Id)) {
					TestedNb += 1;
					declare Player <=> Players[Id];
					for (K, J+1, S_NbPlayersPerTeamMax) {
						if (ClansOrders.existskey(I) && Players.existskey(ClansOrders[I][K])) {
							declare Player2 <=> Players[ClansOrders[I][K]];
							if (Users_AreAllies(Player.User, Player2.User)) AlliesNb += 1;
						}
					}
				}
				J += 1;
			}
			declare MinimumAllies = (((TestedNb - 1) * TestedNb) / 2);
			if (TestedNb > 1 && AlliesNb >= MinimumAllies) AllPlayersAreAllies[I] = True;
		}
	}
	
	declare MatchmakingSetOrderParam2 = "";
	XmlRpc.SendCallback("MatchmakingGetOrder", "");
	
	// ---------------------------------- //
	// Let the players select their orders if they are all allies
	if (AllPlayersAreAllies[1] || AllPlayersAreAllies[2]) {
		UIManager.UIAll.CountdownEndTime = Now + TimeOut + 5000;
		
		if (!AllPlayersAreAllies[1]) WarmUp2::Disable("Clan1");
		if (!AllPlayersAreAllies[2]) WarmUp2::Disable("Clan2");
		
		WarmUp2::DisplayClanSelection(False);
		WarmUp2::Attach();
		
		while (Now < UIManager.UIAll.CountdownEndTime && !ServerShutdownRequested && !MatchEndRequested) {
			MM_Yield();
			ManageCommand();
			WarmUp2::Loop();
			ForceClublinkReload();
			
			if (WarmUp2::Updated()) UpdateLayerScoresTable(C_SequenceWarmUp);
			
			foreach (Event in XmlRpc.PendingEvents) {
				if (Event.Param1 == "MatchmakingSetOrder") MatchmakingSetOrderParam2 = Event.Param2;
				else if (Event.Param1 == "MatchmakingSetTempAllies") G_TempAllies = TextLib::Split(",", Event.Param2);
			}
		}
		
		WarmUp2::Detach();
		WarmUp2::Enable("Clan1");
		WarmUp2::Enable("Clan2");
	} else {
		declare WaitEndTime = Now + 500;
		
		while (Now < WaitEndTime && !ServerShutdownRequested && !MatchEndRequested) {
			MM_Yield();
			ManageCommand();
			ForceClublinkReload();
			
			foreach (Event in XmlRpc.PendingEvents) {
				if (Event.Param1 == "MatchmakingSetOrder") MatchmakingSetOrderParam2 = Event.Param2;
				else if (Event.Param1 == "MatchmakingSetTempAllies") G_TempAllies = TextLib::Split(",", Event.Param2);
			}
		}
	}
	
	// ---------------------------------- //
	// Let the matchmaking server sort the players
	if (MatchmakingSetOrderParam2 != "") {
		UIManager.UIAll.CountdownEndTime = Now + TimeOut;
		PlayersSort[1].clear();
		PlayersSort[2].clear();
		
		declare MatchmakingOrders = TextLib::Split("|", MatchmakingSetOrderParam2);
		for (I, 0, 1) {
			if (!MatchmakingOrders.existskey(I)) continue;
			
			declare MatchmakingOrder = TextLib::Split(",", MatchmakingOrders[I]);
			declare J = 1.;
			foreach (Login in MatchmakingOrder) {
				foreach (Player in Players) {
					if (Player.Login == Login) {
						SetPlayerClan(Player, I+1);
						PlayersSort[I+1][Player.Id] = J;
						J += 1.;
						break;
					}
				}
			}
		}
		
		PlayersSort[1] = PlayersSort[1].sort();
		PlayersSort[2] = PlayersSort[2].sort();
		
		for (I, 1, 2) {
			declare J = 0;
			declare Clan = "";
			if (I == 1) Clan = "Clan1";
			else Clan = "Clan2";
			
			foreach (PlayerId => Sorting in PlayersSort[I]) {
				J += 1;
				if (!Players.existskey(PlayerId)) continue;
				WarmUp2::SetPlayerGroup(Players[PlayerId], Clan);
				WarmUp2::SetPlayerSlot(Players[PlayerId], J, True);
			}
		}
	}
	
	WarmUp2::End();
	WarmUp2::Clean();
	WarmUp2::Fill();
	
	UpdateLayerScoresTable(C_SequenceWarmUp);
	Elite_Sleep(500);
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	
	StartTime = -1;
	UIManager.UIAll.CountdownEndTime = -1;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.UISequence_CanSkipIntroMT = True;
	
	// ---------------------------------- //
	// Update the players clublinks
	if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
	Clublink::SyncUpdate();
	UpdateHeader();
	
	Layers::Update("ScoresTable", CreateLayerScoresTable());
}

// ---------------------------------- //
/// Warm up
Void WarmUp2() {
	XmlRpc::BeginWarmUp();
	+++StartWarmUp+++
	
	if (MB_UseScriptCallbacks && S_UseLegacyCallback) XmlRpc.SendCallback("BeginWarmup", Json::Enfold(Json::Stringify("AllReady", False)));
	
	// Shutdown the poles during warmup
	foreach (Goal in MapLandmarks_Gauge) {
		Goal.Gauge.Clan = 0;
		Goal.Gauge.Speed = 0;
		Goal.Gauge.Value = 0;
		Goal.Gauge.Max = 1000;
		Goal.Gauge.Captured = False;
	}
	SM::UnspawnAllPlayers();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Silence;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
	if (G_Override_NeedWarmUp) UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Pause"));
	else UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm-up"));
	PlaySound(CUIConfig::EUISound::PhaseChange, 0);
	
	WarmUp2::Begin();
	
	// Init players
	foreach (Player in Players) {
		SetPlayerClan(Player, MM_GetRequestedClan(Player));
		if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
		else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
	}
	WarmUp2::Fill();
	
	declare PrevWarmUpDuration = S_WarmUpDuration-1;
	declare PrevMode = -1;
	
	while (!WarmUp2::Stop()) {
		MM_Yield();
		ManageCommand();
		ForceClublinkReload();
		
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		
		foreach (Player in Players) {
			if (Player.CurrentClan != MM_GetRequestedClan(Player)) {
				UnspawnPlayer(Player);
				SetPlayerClan(Player, MM_GetRequestedClan(Player));
				if (Player.CurrentClan == 1) WarmUp2::SetPlayerGroup(Player, "Clan1");
				else if (Player.CurrentClan == 2) WarmUp2::SetPlayerGroup(Player, "Clan2");
			}
		}
		
		if (PrevMode != GetMode() || PrevWarmUpDuration != S_WarmUpDuration) {
			PrevMode = GetMode();
			PrevWarmUpDuration = S_WarmUpDuration;
			
			declare LongTimer = S_WarmUpDuration*1000;
			declare ShortTimer = 5000;
			if (LongTimer <= 0) { LongTimer = 0; ShortTimer = 0; }
			
			if (GetMode() == C_ModeClassic) {
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
			} else {
				WarmUp2::SetGroupTimers("Clan1", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
				WarmUp2::SetGroupTimers("Clan2", [ShortTimer => [-1, 1], LongTimer => [1, 1]]);
			}
		}
		
		WarmUp2::Loop();
		SpawnThemAll(2);
		UpdateSpectators();
		
		if (WarmUp2::Updated()) {
			UpdateLayerScoresTable(C_SequenceWarmUp);
			Clublink::DefineTeamAuto(True);
		}
		
		WarmUp2::ManageEvents();
		foreach (Event in PendingEvents) {
			if (Event.Type == CSmModeEvent::EType::OnHit && Event.Victim != Null && Event.WeaponNum == C_WeaponLaser) {
				DisplayHitDistance(Event.Shooter, Event.Victim, True);
			}
		}
	}
	
	WarmUp2::End();
	
	if (MB_UseScriptCallbacks && S_UseLegacyCallback) XmlRpc.SendCallback("EndWarmup", Json::Enfold(Json::Stringify("AllReady", True)));
	
	PlaySound(CUIConfig::EUISound::StartMatch, 0);
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	SM::UnspawnAllPlayers();
	
	// ---------------------------------- //
	// Update the players clublinks
	if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
	else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
	Clublink::SyncUpdate();
	
	Layers::Update("ScoresTable", CreateLayerScoresTable());
	
	+++EndWarmUp+++
	XmlRpc::EndWarmUp();
}

// ---------------------------------- //
/// Custom stringify for RoundInfo
Text TurnStringify() {
	return Json::Merge([
		Json::Stringify("StartTime", StartTime),
		Json::Stringify("EndTime", EndTime),
		Json::Stringify("PoleTime", (EndTime - (S_TimePole * 1000)))
	]);
}

// ---------------------------------- //
/** Custom stringify for CSmPlayer
 *
 *	@param	_Name			The name of the stringified object
 *	@param	_Player			The player to stringify
 *	@param	_SendPosition	Add the player position
 */
Text PlayerStringify(Text _Name, CSmPlayer _Player, Boolean _SendPosition) {
	declare JSON = "";
	declare Merge = Text[];
	
	if (_Player != Null) {
		if (_Player.Score != Null) {
			declare NbHit for _Player.Score = 0;
			declare LaserHit for _Player.Score = 0;
			declare NbBeHit for _Player.Score = 0;
			
			JSON = Json::ObjectMerge("Score", [
				Json::Stringify("AtkPoints", _Player.Score.Points), 
				Json::Stringify("DefPoints", NbHit),
				Json::Stringify("GoalAverage", NbHit + LaserHit - NbBeHit)
			]);
		}
		
		if (_SendPosition) JSON = Json::Merge([JSON, Json::Stringify("Position", _Player.Position)]);
	}
	
	JSON = Json::StringifyMinimal(_Name, _Player, JSON);
	
	return JSON;
}

// ---------------------------------- //
/// Overload of PlayerStringify()
Text PlayerStringify(Text _Name, CSmPlayer _Player) {
	return PlayerStringify(_Name, _Player, False);
}

// ---------------------------------- //
/** Stringify the players of a clan inside an array
 *
 *	@param	_Name			The name of the stringified object
 *	@param	_Clan			The clan to stringify
 *	@param	_AddTurnHits	Add the turn hits details 
 */
Text PlayersStringify(Text _Name, Integer _Clan, Boolean _AddTurnHits) {
	declare ScoresString = "";
	declare TmpOrder = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	
	declare Start = 1;
	declare End = 2;
	
	if (_Clan == 1) {
		Start = 1; End = 1;
	} else if (_Clan == 2) {
		Start = 2; End = 2;
	}
	
	declare J = 1;
	for (I, Start, End) {
		foreach (Slot => Id in TmpOrder[I]) {
			if (Players.existskey(Id)) {
				declare Player <=> Players[Id];
				if (Player.Score == Null) continue;
				
				if (J > 1) ScoresString ^= ",";
				declare NbHit for Player.Score = 0;
				declare LaserHit for Player.Score = 0;
				declare NbBeHit for Player.Score = 0;
				
				declare Callback = Json::Merge([
					Json::Stringify("Login", Player.Login),
					Json::Stringify("CurrentClan", Player.CurrentClan),
					Json::Stringify("AtkPoints", Player.Score.Points), 
					Json::Stringify("DefPoints", NbHit),
					Json::Stringify("GoalAverage", NbHit + LaserHit - NbBeHit)
				]);
				
				if (_AddTurnHits) {
					declare netwrite Integer[] Net_Elite_HitDetail for Player;
					declare HitsDetails = "[";
					foreach (Key => Hit in Net_Elite_HitDetail) {
						if (Key > 0) HitsDetails ^= ",";
						HitsDetails ^= Hit;
					}
					HitsDetails ^= "]";
					Callback = Json::Merge([Callback, """"TurnHits": {{{HitsDetails}}}"""]);
				}
				
				ScoresString ^= """{"""^Callback^"""}""";
				J += 1;
			}
		}
	}
	
	return """
"{{{_Name}}}":
[
	{{{ScoresString}}}
]""";
}

// ---------------------------------- //
/// Overload of PlayersStringify()
Text PlayersStringify(Text _Name, Integer _Clan) {
	return PlayersStringify(_Name, _Clan, False);
}

/**
 * Rules for the Elite mode
 */

#Extends "Modes/ShootMania/ModeSport.Script.txt"

#Const Version		"2014-03-28"
#Const ScriptName	"Elite.Script.txt"

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/ShootMania/Draft.Script.txt" as Draft
#Include "Libs/Nadeo/ShootMania/LobbyMelee.Script.txt" as Lobby
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable	///< Fix: The lobby can't work without including this lib in Elite
#Include "Libs/Nadeo/ShootMania/Elite/EliteStats.Script.txt" as EliteStats
#Include "Libs/Nadeo/ShootMania/Elite/ElitePractice.Script.txt" as ElitePractice
#Include "Libs/Nadeo/ShootMania/Elite/EliteEndSequence.Script.txt" as EliteEndSequence

#Setting S_TurnWin				9		as _("Number of points to win a map")					///< Score to reach to win a map
#Setting S_UseDraft				False	as _("Use draft mode before match")						///< Use draft mode at match beginning
#Setting S_DraftBanNb			4		as _("Number of map to ban during draft (-1: ban all)")	///< Number of map to ban during draft
#Setting S_DraftPickNb			3		as _("Number of map to pick during draft")				///< Number of map to pick during draft
#Setting S_UseLobby				False	as "<hidden>" // _("Launch server in lobby mode")
#Setting S_LobbyTimePerRound 	60  	as "<hidden>" // _("Time limit per round in lobby mode (sec., 0: no limit)")
#Setting S_LobbyRoundPerMap  	30  	as "<hidden>" // _("Nb of rounds per map in lobby mode")
#Setting S_LobbyMatchmakerTime	10000  	as "<hidden>" // _("in milliseconds, time allocated to the matchmaking")
#Setting S_LobbyInstagib  		False  	as "<hidden>" // _("Laser mode in lobby")
#Setting S_DisplayRulesReminder True	as "<hidden>" // _("Display a window with the rules when the match begins")

#Const S_UseEliteB2				False	//as _("Elite Beta 2 gameplay")							///< Use the beta 2 gameplay settings

#Const C_AtkRocketAmmoMax	4	///< Atk Rocket ammo max
#Const C_AtkRocketAmmoGain	1.	///< Atk Rocket ammo gain
#Const C_AtkLaserAmmoMax	1	///< Atk Laser ammo max
#Const C_AtkLaserAmmoGain	1.	///< Atk Laser ammo gain
#Const C_AtkNucleusAmmoMax	1	///< Atk Nucleus ammo max
#Const C_AtkNucleusAmmoGain	1.	///< Atk Nucleus ammo gain

#Const C_DefRocketAmmoMax	4	///< Def Rocket ammo max
#Const C_DefRocketAmmoGain	1.	///< Def Rocket ammo gain
#Const C_DefLaserAmmoMax	1	///< Def Laser ammo max
#Const C_DefLaserAmmoGain	0.65///< Def Laser ammo gain
#Const C_DefNucleusAmmoMax	1	///< Def Nucleus ammo max
#Const C_DefNucleusAmmoGain	0.75///< Def Nucleus ammo gain

#Const C_MaxDamage 100	///< Maximum damage amount infliged by weapons

#Const C_RequiredPlayersNb	3	///< Required number of players in each team

#Const C_UseToken True	///< Use token in demo mode

// ---------------------------------- //
// Online settings
#Const C_OAtkRocketAmmoMax		"1"	///< Atk Rocket ammo max
#Const C_OAtkLaserAmmoMax		"3"	///< Atk Laser ammo max
#Const C_OAtkLaserAmmoGain		"4"	///< Atk Laser ammo gain
#Const C_OAtkNucleusAmmoMax		"5"	///< Atk Nucleus ammo max

#Const C_ODefRocketAmmoMax		"7"	///< Def Rocket ammo max
#Const C_ODefRocketAmmoGain		"8"	///< Def Rocket ammo gain
#Const C_ODefLaserAmmoMax		"9"	///< Def Laser ammo max
#Const C_ODefNucleusAmmoMax		"11"	///< Def Nucleus ammo max

#Const C_ODefStaminaMaxMultiplier	"17"	///< Stamina amount multiplier for the defense
#Const C_OAtkStaminaMaxMultiplier	"18"	///< Stamina amount multiplier for the attack

#Const Description _("TYPE: Team versus Team (1 vs 3)\nOBJECTIVE:\nOne attacker plays against three defenders. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nThe first team to reach the points limit wins the map.")


declare Integer G_CheckpointsCapturedNb;	///< Number of captured checkpoints

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Draft::GetScriptName(), Draft::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Settings::GetScriptName(), Settings::GetScriptVersion());
MB_LogVersion(Lobby::GetScriptName(), Lobby::GetScriptVersion());
MB_LogVersion(EliteStats::GetScriptName(), EliteStats::GetScriptVersion());
MB_LogVersion(ElitePractice::GetScriptName(), ElitePractice::GetScriptVersion());
MB_LogVersion(EliteEndSequence::GetScriptName(), EliteEndSequence::GetScriptVersion());
***

***Rules***
***
// ---------------------------------- //
// Create rules
declare ModeName = "Elite";
SpawnScreen::AddSubsection(_("Type"), _("Two teams - 1 vs 3"), 0.);
SpawnScreen::AddSubsection(
	_("Objectives"), 
	TextLib::Compose(_("$<%11. $>The game is divided in rounds of two turns each. During a round each team plays one turn in attack and one turn in defense.\n$<%12. $>The attacker has to eliminate all defenders or capture the pole between %2 seconds and %3 seconds. The defenders must eliminate the attacker or prevent them from capturing the pole.\n$<%13. $>The team in attack plays with 1 player using the laser. The team in defense plays with 3 players using rockets."), "$"^SpawnScreen::GetModeColor() , TextLib::ToText(S_TimeLimit - S_TimePole), TextLib::ToText(S_TimeLimit)), 20.);
SpawnScreen::AddSubsection(
	_("Score"), 
	TextLib::Compose(_("$<%11. $>The team that wins the turn scores 1 point.\n$<%12. $>The winning team is the first one to score at least %2 points with %3 ahead of its opponents."), "$"^SpawnScreen::GetModeColor() , TextLib::ToText(S_TurnWin), TextLib::ToText(S_TurnGap)), 85.);
	
SpawnScreen::CreatePrettyRules(ModeName);

ModeStatusMessage = _("TYPE: Team versus Team (1 vs 3)\nOBJECTIVE: Capture the pole when you are the attacker. Defend the pole when you are a defender.");
***

***StartServer***
***
// ---------------------------------- //
// Lobby mode
if (S_UseLobby) Lobby::StartLobbyMode(S_LobbyTimePerRound, S_LobbyRoundPerMap, S_LobbyMatchmakerTime, True, S_LobbyInstagib);
// ---------------------------------- //
// Practice mode
if (S_Practice) ElitePractice::Run();

// ---------------------------------- //
// Init
Layers::Create("Info", CreateLayerInfo());
Layers::Create("Players", CreateLayerPlayers());
// @UIReplay > 
Layers::Create("Replay", CreateLayerReplay());
Layers::Create("PreTurn");

Draft::StartServer();
Settings::Load();
EliteEndSequence::Load();
//EliteStats::Load();

CustomUI::Load();
CustomUI::Add("Elite_Checkpoints", <156., -80.>, <15., 10.>, "bottom", "right");
CustomUI::Add("Elite_AtkArmor", <156., -88.>, <15., 10.>, "bottom", "right");
CustomUI::Add("Elite_GaugeCapture", <0., -40.>, <145., 16.>, "center", "center");
CustomUI::Add("Elite_Sponsors", <90., -88.>, <40., 20.>, "bottom", "left");
CustomUI::Add("Elite_PlayersList_1", <-160., 74.>, <60., 18.>, "top", "left");
CustomUI::Add("Elite_PlayersList_2", <160., 74.>, <60., 18.>, "top", "right");
CustomUI::Build();

G_UseEliteB2 = S_UseEliteB2;
MB_UseOnNewLabels = False;

if (G_UseEliteB2) {
	GameplayVersion		= 1;
	UseAmmoBonusOnHit	= False;
	UseLaserSkewering	= False;
	UseProtectClanmates	= False;
} else {
	GameplayVersion		= 0;
	UseAmmoBonusOnHit	= True;
	UseLaserSkewering	= True;
	UseProtectClanmates	= True;
}

// ---------------------------------- //
// Manual replay control
Replay_AutoStart = False;
***

***StartMatch***
***
declare MapPlayedSinceMatchBeginning = 0;	///< Even maps skipped by a vote
if (S_UseDraft) {
	Mode::LoadMap();
	
	G_TieBreakDefElim = [1 => 0, 2 => 0];
	G_AtkClan = 1;
	G_DefClan = 2;
	Clan1Score = 0;
	Clan2Score = 0;
	Users_SetNbFakeUsers(C_BlueBotsNb, C_RedBotsNb);
	
	// ---------------------------------- //
	// Initialize UI
	UIManager.ResetAll();
	InitUi();
	SpawnScreen::AttachRules();
	Layers::Attach("ScoresTable");
	Clublink::Attach();
	Clublink::SetSponsorsDisplay(False);
	
	MB_CurrentSection = "WarmUp";
	WarmUp2();
	MB_CurrentSection = "StartMatch";
	
	Layers::Detach("ScoresTable");
	
	declare Order = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	declare Selected = [1 => Ident[], 2 => Ident[]];
	for (I, 1, 2) {
		foreach (Slot => PlayerId in Order[I]) {
			Selected[I].add(PlayerId);
		}
	}
	Draft::SetPlayersSelected(Selected);
	if (G_Override_TossWinner == 1 || G_Override_TossWinner == 2) {
		TossWinner = G_Override_TossWinner;
		G_Override_TossWinner = -1;
	} else {
		TossWinner = Toss::Toss();
	}
	Draft::MapSelection(S_DraftBanNb, S_DraftPickNb, TossWinner);
	
	declare TmpNextMapIndex = Draft::GetMapIndex(1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
	
	Mode::UnloadMap();
}
***

***RulesReminder***
***
	if(S_Matchmaking) CreateRulesReminderLayer();
***

***StartMap***
***
UseLaserVsBullets = True;
EliteEndSequence::InitPlayersList();
//EliteStats::StartMap();
CustomUI::Attach();

declare netwrite Integer Net_Elite_BestDodgeTotal for Teams[0];
declare netwrite Text Net_Elite_BestDodgeName for Teams[0];
Net_Elite_BestDodgeTotal = 0;
Net_Elite_BestDodgeName = "";
foreach (Score in Scores) {
	declare DodgeTotal for Score = 0;
	DodgeTotal = 0;
}
***

***InitTurn***
***
declare StartReplay = True;
***

***StartTurn***
***
G_CheckpointsCapturedNb = 0;

foreach (Player in AllPlayers) {
	declare netwrite Text Net_Elite_HitDetailUpdate for Player;
	declare netwrite Integer[] Net_Elite_HitDetail for Player;
	Net_Elite_HitDetailUpdate = Player.Login^"_"^Now;
	Net_Elite_HitDetail.clear();
}

Layers::Attach("Info");
Layers::Attach("Players");
Layers::Update("Info", CreateLayerInfo());
Layers::Update("Players", CreateLayerPlayers());
UpdateLayerInfo();
UpdateLayerPlayers();

Replay_Start();
MB_Sleep(1);
Layers::Update("PreTurn", CreateLayerPreTurn(TeamAtkName, TeamDefName, NextAtkName));
Layers::DetachReplay("Replay");
Layers::AttachReplay("PreTurn");
Replay_SaveInterface();
***

***PlayLoop***
***
// @UIReplay > 
if (StartReplay && Now > StartTime) {
	Layers::Update("Replay", CreateLayerReplay());
	Layers::DetachReplay("PreTurn");
	Layers::AttachReplay("Replay");
	Replay_SaveInterface();
	StartReplay = False;
}
***

***EndReplay***
***
Replay_Stop();
***

***EndTurnBegin***
***
foreach(Player in Players) {
	declare NbHit for Player.Score = 0;
	Replay_SaveAttackScore(Player, Player.Score.Points);
	Replay_SaveDefenseScore(Player, NbHit);
	
	if(Player.CurrentClan == WinnerTurnClan) {			
		Replay_SaveWinner(Player);
	}
}
Replay_SaveTeamScore(1, Clan1Score);
Replay_SaveTeamScore(2, Clan2Score);
if (Players.existskey(G_AtkPlayerId)) {
	Replay_SavePlayerOfInterest(Players[G_AtkPlayerId]);
}

declare PlayersList = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
EliteEndSequence::SavePlayersList(PlayersList);

// @UIReplay > 
Layers::Update("Replay", CreateLayerReplay());
Replay_SaveInterface();
***

***SelectNextMap***
***
MapPlayedSinceMatchBeginning += 1;
if (S_UseDraft) {
	declare TmpNextMapIndex = Draft::GetMapIndex(MapPlayedSinceMatchBeginning + 1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
}
***

***EndSequenceStart***
***
EliteEndSequence::Update(WinnerMapClan);
EliteEndSequence::Attach();
***

***EndSequenceEnd***
***
EliteEndSequence::Detach();
***
/*
***EndMap***
***
EliteStats::EndMap();
***
*/
***EndServer***
***
Layers::Destroy("Info");
Layers::Destroy("Players");
Draft::EndServer();
Settings::Unload();
EliteEndSequence::Unload();
//EliteStats::Unload();
CustomUI::Unload();
***

***StartUsingToken***
***
if (C_UseToken) DemoToken_StartUsingToken();
***

***GetAndUseToken***
***
if (C_UseToken) {
	declare TokenOrder = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	foreach (Clan => Order in TokenOrder) {
		foreach (Slot => PlayerId in Order) {
			if (!Players.existskey(PlayerId)) continue;
			DemoToken_GetAndUseToken(Players[PlayerId].User);
		}
	}
}
***

***StopUsingToken***
***
if (C_UseToken) DemoToken_StopUsingToken();
***

***SpawnDef***
***
if (DefSpawned >= MaxDef) break;
if (!Players.existskey(PlayerId)) continue;
declare Player <=> Players[PlayerId];

SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, Settings::GetInteger(C_ODefRocketAmmoMax, C_DefRocketAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, Settings::GetInteger(C_ODefLaserAmmoMax, C_DefLaserAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_ODefNucleusAmmoMax, C_DefNucleusAmmoMax));

declare DefWeapon	= CSmMode::EWeapon::Rocket;
Player.AmmoGain		= Settings::GetReal(C_ODefRocketAmmoGain, C_DefRocketAmmoGain);
Player.StaminaMax	= Settings::GetReal(C_ODefStaminaMaxMultiplier, C_DefStaminaMaxMultiplier);
Player.StaminaGain	= Settings::GetReal(C_ODefStaminaMaxMultiplier, C_DefStaminaMaxMultiplier);
Player.ArmorMax		= C_DefArmorMax;
SetPlayerWeapon(Player, DefWeapon, True);
SM::SpawnPlayer(Player, G_DefClan, Player.ArmorMax, DefSpawn, Now);
SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_ODefNucleusAmmoMax, C_DefNucleusAmmoMax));
Player.IsHighlighted = True;
DefSpawned += 1;
***

***SpawnAtk***
***
if (AtkSpawned >= MaxAtk) break;
if (PlayerId != G_AtkPlayerId) continue;
if (!Players.existskey(PlayerId)) break;			
declare Player <=> Players[PlayerId];

SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, Settings::GetInteger(C_OAtkRocketAmmoMax, C_AtkRocketAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, Settings::GetInteger(C_OAtkLaserAmmoMax, C_AtkLaserAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_OAtkNucleusAmmoMax, C_AtkNucleusAmmoMax));

Player.AmmoGain		= Settings::GetReal(C_OAtkLaserAmmoGain, C_AtkLaserAmmoGain);
Player.StaminaMax	= Settings::GetReal(C_OAtkStaminaMaxMultiplier, C_AtkStaminaMaxMultiplier);
Player.StaminaGain	= Settings::GetReal(C_OAtkStaminaMaxMultiplier, C_AtkStaminaMaxMultiplier);

if (S_Mode == 1 || S_Matchmaking) Player.ArmorMax = DefSpawned * 100;
else Player.ArmorMax = C_AtkArmorMax;
if (Player.ArmorMax < 100) Player.ArmorMax = 100;

declare netwrite Integer Net_Elite_AtkArmorsLeft for Teams[0];
Net_Elite_AtkArmorsLeft = Player.ArmorMax / 100;

SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False); 
SM::SpawnPlayer(Player, G_AtkClan, Player.ArmorMax, AtkSpawn, Now);
SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_OAtkNucleusAmmoMax, C_AtkNucleusAmmoMax));
Player.IsHighlighted = True;
//G_AtkPlayerId = PlayerId;
AtkSpawned += 1;
***

***PoleManagement***
***
if (Now >= PoleTime) {
	// ---------------------------------- //
	// When the goal can be captured
	if (!GoalCanBeCaptured) {
		GoalCanBeCaptured = True;
		Message::SetDefaultStatusMessage(_("The goal can now be captured."));
		PlaySound(CUIConfig::EUISound::PhaseChange, 0); 
		UIManager.UIAll.CountdownEndTime = -1;
	}
	
	// ---------------------------------- //
	// Check if the attacker is capturing the pole
	foreach (Goal in Goals) {		
		if (Goal.Gauge.Value == 0 && Goal.Gauge.Clan == G_DefClan) {
			Goal.Gauge.Clan = G_AtkClan;
			// Set the Max value depending on the number of checkpoints in the map
			if (Checkpoints.count <= 0) {
				Goal.Gauge.Max = MathLib::NearestInteger(S_TimeCapture * 1000) * MapLandmarks_Gauge.count;
			} else {
				// + 1 in order to see the gauge filled (With a Max of 0 the gauge can't be filled)
				Goal.Gauge.Max = ((Checkpoints.count - G_CheckpointsCapturedNb) * 1000) + 500;
			}
		}
		
		if (Goal.Sector.PlayersIds.exists(G_AtkPlayerId)) {
			if(Goal.Gauge.Clan == G_DefClan) {
				Goal.Gauge.Speed = -1;
			} else {
				Goal.Gauge.Speed = 1;
			}
		} else {
			Goal.Gauge.Speed = 0;
		}
	}
} else {
	// ---------------------------------- //
	// Monitor the checkpoints
	foreach (Checkpoint in Checkpoints) {
		if (Checkpoint.Gauge.Captured) continue;
		
		if (Checkpoint.Sector.PlayersIds.exists(G_AtkPlayerId)) {
			Checkpoint.Gauge.Speed = 1000;
		}
	}
}	
***

***ValidateEvents***
***
if (!Win_TimeLimit && !Win_AtkEliminated && !Win_LastDefEliminated && !Win_Capture) {
	declare RemainingDef = ClansNbPlayersAlive[G_DefClan];
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnHit) {
			if (Event.Shooter != Null && Event.Victim != Null && Event.Shooter.CurrentClan != Event.Victim.CurrentClan) {
				declare EventDamage = Event.Damage;
				if (EventDamage > C_MaxDamage) EventDamage = C_MaxDamage;
				
				// Last hit on the atk
				if (Event.Victim.Id == G_AtkPlayerId && Event.Victim.Armor - EventDamage <= 0) {
					Win_AtkEliminated = True;
				} 
				// Last hit on def
				else if (Event.Victim.CurrentClan == G_DefClan) {
					if (Event.Victim.Armor - EventDamage <= 0) RemainingDef -= 1;
				}
			}
		} else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
			if (Event.Victim != Null) {
				// Self elim (offzone, ...) on the atk
				if (Event.Victim.Id == G_AtkPlayerId) {
					Win_AtkEliminated = True;
				} 
				// Self elim on the def
				else if (Event.Victim.CurrentClan == G_DefClan) {
					RemainingDef -= 1;
				}
			}
		} else if (Event.Type == CSmModeEvent::EType::OnCapture) {
			// Capture the pole
			if (Event.Landmark.Tag == "Goal A" || Event.Landmark.Tag == "Goal B" || Event.Landmark.Tag == "Goal C") {
				Win_Capture = True;
			}
		} else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
			// Respawn of the atk
			if (Event.Player.Id == G_AtkPlayerId) {
				Win_AtkEliminated = True;
			}
			// Respawn of the last def
			else if (Event.Player.CurrentClan == G_DefClan) {
				RemainingDef -= 1;
			}
		} 
	}
	
	// Last hit on last def
	if (RemainingDef <= 0) Win_LastDefEliminated = True;
					
	// Time limit
	if (Now >= EndTime) Win_TimeLimit = True;
	
	// Atk deco
	if (
		!Players.existskey(G_AtkPlayerId) 
		|| (Players.existskey(G_AtkPlayerId) && Players[G_AtkPlayerId].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
	) {
		Win_AtkEliminated = True;
	}
	
	// Last def deco
	if (ClansNbPlayersAlive[G_DefClan] <= 0) {
		Win_LastDefEliminated = True;
	}
	
	if (Win_TimeLimit) {
		Win_AtkEliminated = False;
		Win_LastDefEliminated = False;
		Win_Capture = False;
	} else if (Win_LastDefEliminated) {
		Win_TimeLimit = False;
		Win_AtkEliminated = False;
		Win_Capture = False;
	} else if (Win_AtkEliminated) {
		Win_TimeLimit = False;
		Win_LastDefEliminated = False;
		Win_Capture = False;
	} else if (Win_Capture) {
		Win_TimeLimit = False;
		Win_AtkEliminated = False;
		Win_LastDefEliminated = False;
	}
}
***

***EventOnHit***
***
if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
	Discard(Event);
} else {
	if (Event.Damage > C_MaxDamage) Event.Damage = C_MaxDamage;
	if (Players.existskey(G_AtkPlayerId)) {
		// ---------------------------------- //
		// Shooter is in atk clan, victim in def clan
		if (Event.Shooter.Id == G_AtkPlayerId) {
			if (LastActionClanNb != G_AtkClan) SoundVariant += 1;
			LastActionClanNb = G_AtkClan;
			DefElimintedNb += 1;
			
			// Elim last defenders
			if (ClansNbPlayersAlive[G_DefClan] <= 1 || DefElimintedNb >= ClansNbPlayersAlive[G_DefClan]) {
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
			} 
			// Elim standard defenders
			else {
				PlaySound(CUIConfig::EUISound::TieBreakPoint, SoundVariant);
			}
			
			if (ClansNbPlayersAlive[G_DefClan] > 1) {
				declare DefLeft = ClansNbPlayersAlive[G_DefClan] - 1;
				if (DefLeft <= 1) {
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", 
							Teams[G_DefClan - 1].ColorText,
							_("1 defender left.")
						), 3000, 2
					);
				} else {
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 defenders left."), 
							Teams[G_DefClan - 1].ColorText, 
							TextLib::ToText(DefLeft)
						), 3000, 2
					);
				}
			}
			
			DisplayHitDistance(Event.Shooter, Event.Victim, False);
			if (Event.Shooter.Score != Null && Event.Victim != Null) {
				declare LaserLongest for Event.Shooter.Score = 0.;
				declare LaserHit for Event.Shooter.Score = 0;
				declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
				if (Distance > LaserLongest) LaserLongest = Distance;
				LaserHit += 1;
			}
			
			declare netwrite Text Net_Elite_HitDetailUpdate for Event.Shooter;
			declare netwrite Integer[] Net_Elite_HitDetail for Event.Shooter;
			Net_Elite_HitDetailUpdate = Event.Shooter.Login^"_"^Now;
			Net_Elite_HitDetail.add(Event.WeaponNum);
		} 
		// ---------------------------------- //
		// Shooter is in def clan, victim in atk clan
		else {
			if (LastActionClanNb != G_DefClan) SoundVariant += 1;
			LastActionClanNb = G_DefClan;
			
			// Elim attacker
			if (Players[G_AtkPlayerId].Armor <= 100 && Event.Victim.Id == G_AtkPlayerId) {
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
				AtkIsEliminated = True;	///< Set atk elimination at the frame of the hit, not the next OnArmorEmpty
			} 
			// Hit attacker
			else {
				PlaySound(CUIConfig::EUISound::TiePoint, SoundVariant);
			}
			
			if (Players[G_AtkPlayerId].Armor > 100) {
				declare ArmorLeft = (Players[G_AtkPlayerId].Armor - 100) / 100;
				if (ArmorLeft <= 1) {
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", Teams[G_AtkClan - 1].ColorText, _("1 armor left.")
						), 3000, 2
					);
				} else {
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 armors left."), 
							Teams[G_AtkClan - 1].ColorText, 
							TextLib::ToText(ArmorLeft)
						), 3000, 2
					);
				}
			}
			
			if (Event.Shooter.Score != Null) {
				declare NbHit for Event.Shooter.Score = 0;
				declare NbElimination for Event.Shooter.Score = 0;
				declare DefRatio for Event.Shooter.Score = 0.;
				NbHit += 1;
				if (NbElimination <= 0) DefRatio = MathLib::ToReal(NbHit) / 1.;
				else DefRatio = MathLib::ToReal(NbHit) / MathLib::ToReal(NbElimination);
			}
			
			declare netwrite Text Net_Elite_HitDetailUpdate for Event.Shooter;
			declare netwrite Integer[] Net_Elite_HitDetail for Event.Shooter;
			Net_Elite_HitDetailUpdate = Event.Shooter.Login^"_"^Now;
			Net_Elite_HitDetail.add(Event.WeaponNum);
			
			if (Event.Victim.Id == G_AtkPlayerId) {
				declare netwrite Integer Net_Elite_AtkArmorsLeft for Teams[0];
				Net_Elite_AtkArmorsLeft = (Event.Victim.Armor - Event.Damage) / 100;
			}
		}
	}
	
	if (Event.Victim.Score != Null) {
		declare NbBeHit for Event.Victim.Score = 0;
		NbBeHit += 1;
	}
	
	UpdateLayerScoresTable(C_SequencePlaying);
	
	// Stats
	if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
		declare JSON = Json::Enfold(EliteStringify("Event", Event));
		XmlRpc.SendCallback("OnHit", JSON);
	}
	XmlRpc::OnHit(Event);
	
	// Don't forget to send stats for the atk elimination because we won't trigger the OnArmorEmpty event
	if (AtkIsEliminated) {
		if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
			declare JSON2 = Json::Enfold(EliteStringifySimulateArmorEmpty("Event", Event));
			XmlRpc.SendCallback("OnArmorEmpty", JSON2);
		}
		G_AtkElimPlayerId = Event.Shooter.Id;
		XmlRpc::OnArmorEmpty(Event);
	}
	
	// @UIReplay > 
	Layers::Update("Replay", CreateLayerReplay());
	Replay_SaveInterface();
	
	PassOn(Event);
}
***

***EventOnArmorEmpty***
***
if (Event.Shooter != Null && Event.Shooter.CurrentClan == G_AtkClan) {
	G_MatchDefElim[Event.Shooter.CurrentClan] += 1;
	G_MapDefElim[Event.Shooter.CurrentClan] += 1;
	if (G_TieBreak) G_TieBreakDefElim[Event.Shooter.CurrentClan] += 1;
}

if (Event.Victim != Null && Event.Victim.Score != Null) {
	declare NbHit for Event.Victim.Score = 0;
	declare NbElimination for Event.Victim.Score = 0;
	declare DefRatio for Event.Victim.Score = 0.;
	NbElimination += 1;
	if (NbElimination <= 0) DefRatio = MathLib::ToReal(NbHit) / 1.;
	else DefRatio = MathLib::ToReal(NbHit) / MathLib::ToReal(NbElimination);
	
	if (Event.Victim.IsInOffZone) {
		declare NbBeHit for Event.Victim.Score = 0;
		NbBeHit += Event.Victim.Armor / 100;
	}
}

UpdateLayerScoresTable(C_SequencePlaying);

// Stats
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	XmlRpc.SendCallback("OnArmorEmpty", JSON);
}

XmlRpc::OnArmorEmpty(Event);
PassOn(Event);
***

***EventOnPlayerRequestRespawn***
***
if (Event.Player != Null && Event.Player.Score != Null) {
	declare NbHit for Event.Player.Score = 0;
	declare NbElimination for Event.Player.Score = 0;
	declare DefRatio for Event.Player.Score = 0.;
	NbElimination += 1;
	if (NbElimination <= 0) DefRatio = MathLib::ToReal(NbHit) / 1.;
	else DefRatio = MathLib::ToReal(NbHit) / MathLib::ToReal(NbElimination);
	
	declare NbBeHit for Event.Player.Score = 0;
	NbBeHit += Event.Player.Armor / 100;
	
	UpdateLayerScoresTable(C_SequencePlaying);
}

if (Event.Player != Null && Event.Player.CurrentClan == G_DefClan) {
	G_MatchDefElim[Event.Player.CurrentClan] += 1;
	G_MapDefElim[Event.Player.CurrentClan] += 1;
	if (G_TieBreak && G_TieBreakDefElim.existskey(3 - G_DefClan)) G_TieBreakDefElim[3 - G_DefClan] += 1;
}

// Stats
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	XmlRpc.SendCallback("OnPlayerRequestRespawn", JSON);
}

XmlRpc::OnPlayerRequestRespawn(Event);
PassOn(Event);
***

***EventOnCapture***
***
if (Event.Landmark.Tag == "Checkpoint") {
	G_CheckpointsCapturedNb += 1;
	// If the pole can already be captured, update its max value here
	if (Now >= PoleTime) {
		foreach (Goal in Goals) {
			Goal.Gauge.Max = ((Checkpoints.count - G_CheckpointsCapturedNb) * 1000) + 1;
		}
	}
	
	Message::SendStatusMessage(_("Checkpoint captured."), 2000, 2, CUIConfig::EUISound::Capture, 0);
} else if (Event.Landmark.Tag == "Goal A" || Event.Landmark.Tag == "Goal B" || Event.Landmark.Tag == "Goal C") {
	PlaySound(CUIConfig::EUISound::Capture, 0);
}

UpdateLayerInfo();

// Stats
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	XmlRpc.SendCallback("OnCapture", JSON);
}

XmlRpc::OnCapture(Event);
PassOn(Event);
***

***EventOnShoot***
***
if (
	Event.Shooter != Null 
	&& Event.Shooter.Id == G_AtkPlayerId 
	&& Event.Shooter.Score != Null
	&& Event.WeaponNum == C_WeaponLaser
) {
	declare LaserShot for Event.Shooter.Score = 0;
	LaserShot += 1;
	//UpdateLayerScoresTable(C_SequencePlaying);
}

// Stats
if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	XmlRpc.SendCallback("OnShoot", JSON);
}

XmlRpc::OnShoot(Event);
PassOn(Event);
***

***EventOnNearMiss***
***
if (Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser)) {
	declare MaxMissDist = 0.5;
	if (Event.Shooter != Null && Event.Victim != Null) {
		declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
		MaxMissDist = Distance * 2 / 100;
		if (MaxMissDist > 0.5) MaxMissDist = 0.5;
	}
	
	if (Event.Shooter.CurrentClan == G_AtkClan && Event.MissDist <= MaxMissDist) {
		if (Event.MissDist < 0.01) {
			Message::SendStatusMessage(
				TextLib::Compose(
					_("%1$<%2$> misses $<%3$> by %4cm."), 
					Teams[G_AtkClan - 1].ColorText,
					Event.Shooter.Name, 
					Event.Victim.Name,
					TextLib::ToText(1)
				), 3000, 2
			);
		} else {
			Message::SendStatusMessage(
				TextLib::Compose(
					_("%1$<%2$> misses $<%3$> by %4cm."), 
					Teams[G_AtkClan - 1].ColorText,
					Event.Shooter.Name, 
					Event.Victim.Name,
					TextLib::ToText(MathLib::CeilingInteger(Event.MissDist*100))
				), 3000, 2
			);
		}
		
		// Stats
		if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
			declare JSON = Json::Enfold(EliteStringify("Event", Event));
			XmlRpc.SendCallback("OnNearMiss", JSON);
		}
		
		XmlRpc::OnNearMiss(Event);
		PassOn(Event);
	} else {
		Discard(Event);
	}
} else if (Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Rocket)) {
	if (Event.Victim != Null && Event.Victim.Score != Null) {
		declare Integer DodgeTotal for Event.Victim.Score;
		DodgeTotal += 1;
		
		declare netwrite Integer Net_Elite_BestDodgeTotal for Teams[0];
		declare netwrite Text Net_Elite_BestDodgeName for Teams[0];
		if (DodgeTotal > Net_Elite_BestDodgeTotal) {
			Net_Elite_BestDodgeTotal = DodgeTotal;
			Net_Elite_BestDodgeName = Event.Victim.Name;
		}
		
		if (Event.Victim.Id == G_AtkPlayerId) {
			declare Message = _("%1$<%2$> dodged %3 rocket.");
			if (DodgeTotal > 1) Message = _("%1$<%2$> dodged %3 rockets.");
			Message::SendStatusMessage(
				TextLib::Compose(
					Message, 
					Teams[G_AtkClan - 1].ColorText,
					Event.Victim.Name, 
					TextLib::ToText(DodgeTotal)
				), 3000, 2
			);
		}
	}
	
	// Stats
	if (MB_UseScriptCallbacks && S_UseLegacyCallback) {
		declare JSON = Json::Enfold(EliteStringify("Event", Event));
		XmlRpc.SendCallback("OnNearMiss", JSON);
	}
	
	XmlRpc::OnNearMiss(Event);
	PassOn(Event);
} else {
	Discard(Event);
}
***

***EventOnPlayerAdded***
***
UpdateLayerPlayers();
***

***EventOnPlayerRemoved***
***
UpdateLayerPlayers();
***

***EndTurnUIStart***
***
Layers::Detach("Info");
UIManager.UIAll.MarkersXML = "";
***

***ForceWarmUp***
***
Layers::Detach("Players");
***

***EndTurnUIStop***
***
Layers::Detach("Players");
***

***CreatePlayersListBig***
***
	declare ML ="";
	declare PosX = 0.;
	declare PosY = 0.;
	declare Col = 2.;
	declare PlayersByCol = MathLib::NearestInteger(_Nb/Col);
	declare S = _Scale;
	declare K = 1;
	declare AvatarSize = 8;
	declare Star = <3., 3.>;
	
	declare RocketHidden = 0;
	if (_Mode == 2) RocketHidden = 1;
	
	declare Team1Color = TextLib::ColorToText(Teams[0].ColorPrimary);
	declare Team2Color = TextLib::ColorToText(Teams[1].ColorPrimary);
	
	declare PathCommon = "file://Media/Manialinks/ShootMania/Common/";
	declare PathElite = "file://Media/Manialinks/ShootMania/Elite/";
	
	declare StarStyle = """ valign="center" style="BgRaceScore2" substyle="Fame" """;
	
	declare Tags = [1 => "", 2 => ""];
	declare TagSize = <6., 3.>;
	declare MedalSize = <2., 3.>;
	declare MedalPosX = 0.;
	declare TagPosX = MedalSize.X * 0.4;
	declare ColHAlign = [1 => "right", 2 => "left"];
	for (I, 1, 2) {
		declare Side = 1;
		if (I >= 2) Side = -1;
		
		switch (ColHAlign[I]) {
			case "left"		: { MedalPosX = 0.; TagPosX = MedalSize.X * 0.4; }
			case "center"	: { MedalPosX = -TagSize.X/2. * 0.8; TagPosX = MedalSize.X*0.4 / 2.; }
			case "right"	: { MedalPosX = -TagSize.X * 0.8; TagPosX = 0.; }
		}
		
		Tags[I] = """
<frame posn="{{{64*S*Side}}} -0.3" id="Frame_Tags">
	<frame posn="0 0">
		<quad posn="{{{MedalPosX}}} 0" sizen="{{{MedalSize.X}}} {{{MedalSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" style="Icons64x64_1" substyle="TagTypeNone" />
		<quad posn="{{{TagPosX}}} 0" sizen="{{{TagSize.X}}} {{{TagSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" />
	</frame>
	<frame posn="{{{(MedalSize.X+TagSize.X)*Side*-1}}} 0">
		<quad posn="{{{MedalPosX}}} 0" sizen="{{{MedalSize.X}}} {{{MedalSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" style="Icons64x64_1" substyle="TagTypeNone" />
		<quad posn="{{{TagPosX}}} 0" sizen="{{{TagSize.X}}} {{{TagSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" />
	</frame>
	<frame posn="{{{(MedalSize.X+TagSize.X)*2*Side*-1}}} 0">
		<quad posn="{{{MedalPosX}}} 0" sizen="{{{MedalSize.X}}} {{{MedalSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" style="Icons64x64_1" substyle="TagTypeNone" />
		<quad posn="{{{TagPosX}}} 0" sizen="{{{TagSize.X}}} {{{TagSize.Y}}}" halign="{{{ColHAlign[I]}}}" valign="center" />
	</frame>
</frame>""";
	}
	
	ML ^= """
<framemodel posn="0 0" id="Frame_PlayerLeft">
	<gauge posn="-1.8 -11.5 1" sizen="{{{87.*S}}} 14" valign="center" color="{{{Team1Color}}}7" style="EnergyBar" drawbg="0" drawblockbg="0" id="Quad_Armors" />
	<gauge posn="-1.8 -11.5 1" sizen="{{{86.3*S}}} 14" valign="center" color="{{{Team1Color}}}7" style="EnergyBar" drawbg="0" drawblockbg="1" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{82.25*S}}} 10" bgcolor="{{{Team1Color}}}" opacity="0.3" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{82.25*S}}} 14.1" bgcolor="000" opacity="0.6" id="Quad_Eliminated" hidden="1" />
	<frame posn="0 0.4">
		<quad posn="-1. -0.3 -3" sizen="3.5 14.1" halign="right" hidden="1" id="Quad_Echelon" />
		<quad posn="0.5 -0.8 2" sizen="{{{2*S}}} 9" image="{{{PathElite}}}NotReady.dds" id="Quad_NotReady" />
		<quad posn="0.5 -0.8 2" sizen="{{{2*S}}} 9" image="{{{PathElite}}}Ready.dds" hidden="1" id="Quad_Ready" />
		<quad posn="{{{(3*S)+4}}} -1.40 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" bgcolor="0003" id="Quad_Avatar" />
		<label posn="{{{17*S}}} -5 3" sizen="{{{45*S}}} 12" textsize="3" valign="center" id="Label_Name" />
		<frame posn="{{{64*S}}} -5 4" id="Frame_Stars" hidden="1">
			<quad posn="0 0" sizen="{{{Star.X}}} {{{Star.Y}}}" halign="right" {{{StarStyle}}} id="Quad_Star_1" />
			<quad posn="{{{-Star.X*1.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" halign="right" {{{StarStyle}}} id="Quad_Star_2" />
			<quad posn="{{{-Star.X*2.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" halign="right" {{{StarStyle}}} id="Quad_Star_3" />
			<quad posn="{{{-Star.X*3.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" halign="right" {{{StarStyle}}} id="Quad_Star_4" />
			<quad posn="{{{-Star.X*4.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" halign="right" {{{StarStyle}}} id="Quad_Star_5" />
		</frame>
		<frame id="Frame_Points">
			<frame posn="{{{69*S}}} -5 2">
				<label posn="0 0" sizen="{{{5*S}}} 3" textsize="3" halign="left" valign="center" id="Label_Ratio" />
				<quad posn="-0.5 -0.5" sizen="4 4" halign="right" valign="center" image="{{{PathCommon}}}Rocket.dds" hidden="{{{RocketHidden}}}" id="Quad_Ratio" />
			</frame>
			<label posn="{{{76*S}}} -5 3" sizen="{{{5*S}}} 5" textsize="5" halign="left" valign="center" id="Label_AtkPoints" />
		</frame>
	</frame>
	<frame posn="0 -11.8 3">
		<frame posn="{{{3.5*S}}} 0">
			<quad posn="0 -0.3" sizen="2.5 2.5" halign="right" valign="center" image="file://Media/Manialinks/Common/AllyNo.dds" id="Quad_Ally" />
			<label posn="1 0" sizen="{{{24*S}}} 5" textsize="1" textemboss="1" valign="center" id="Label_Rank" />
		</frame>
		<frame posn="{{{64*S}}} 0" id="Frame_LadderPoints" hidden="1">
			<format textcolor="bb8" textsize="1" />
			<quad posn="-18 -0.2" sizen="5 5" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-23.5 0" sizen="10 5" halign="right" valign="center" id="Label_LadderPoints"/>
			<quad posn="0 -0.2" sizen="5 5" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-5.5 0" sizen="10 5" halign="right" valign="center" id="Label_LadderPointsTotal" />
		</frame>
		<frame posn="{{{69*S}}} -0.1" id="Frame_Stats">
			<format textcolor="444" textsize="1" />
			<label posn="6 0.2" sizen="10 5" halign="center" valign="center" opacity="0.3" id="Label_StatsAverage" />
			<quad posn="0 -0.2" sizen="3 3" halign="right" valign="center" opacity="0.4" image="{{{PathCommon}}}Shield.dds" />
		</frame>
		{{{Tags[1]}}}
	</frame>
</framemodel>
<framemodel posn="0 0" id="Frame_PlayerRight">
	<gauge posn="1.8 -11.5 1" sizen="{{{87.*S}}} 14" halign="right" valign="center" color="{{{Team2Color}}}7" style="EnergyBar" drawbg="0" drawblockbg="0" id="Quad_Armors" />
	<gauge posn="1.8 -11.5 1" sizen="{{{86.3*S}}} 14" halign="right" valign="center" color="{{{Team2Color}}}7" style="EnergyBar" drawbg="0" drawblockbg="1" />
	<quad posn="{{{0*S}}} 0 1" sizen="{{{82.25*S}}} 10" bgcolor="{{{Team2Color}}}" opacity="0.3" halign="right" id="Quad_Attacker" hidden="1" />
	<quad posn="{{{0*S}}} 0 5" sizen="{{{82.25*S}}} 14.1" bgcolor="000" opacity="0.6" halign="right" id="Quad_Eliminated" hidden="1" />
	<frame posn="0 0.4">
		<quad posn="1. -0.3 -3" sizen="3.5 14.1" hidden="1" id="Quad_Echelon" />
		<quad posn="-0.5 -0.8 2" sizen="{{{2*S}}} 9" halign="right" image="{{{PathElite}}}NotReady.dds" id="Quad_NotReady" />
		<quad posn="-0.5 -0.8 2" sizen="{{{2*S}}} 9" halign="right" image="{{{PathElite}}}Ready.dds" hidden="1" id="Quad_Ready" />
		<quad posn="{{{(-3*S)-4}}} -1.40 2" sizen="{{{AvatarSize}}} {{{AvatarSize}}}" halign="center" bgcolor="0003" id="Quad_Avatar" />
		<label posn="{{{-17*S}}} -5 3" sizen="{{{45*S}}} 12" textsize="3" halign="right" valign="center" id="Label_Name" />
		<frame posn="{{{-32*S}}} -5 4" id="Frame_Stars" hidden="1">
			<quad posn="0 0" sizen="{{{Star.X}}} {{{Star.Y}}}" {{{StarStyle}}} id="Quad_Star_1" />
			<quad posn="{{{Star.X*1.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" {{{StarStyle}}} id="Quad_Star_2" />
			<quad posn="{{{Star.X*2.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" {{{StarStyle}}} id="Quad_Star_3" />
			<quad posn="{{{Star.X*3.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" {{{StarStyle}}} id="Quad_Star_4" />
			<quad posn="{{{Star.X*4.}}} 0" sizen="{{{Star.X}}} {{{Star.Y}}}" {{{StarStyle}}} id="Quad_Star_5" />
		</frame>
		<frame id="Frame_Points">
			<frame posn="{{{-69*S}}} -5 2">
				<label posn="0 0" sizen="{{{5*S}}} 3" textsize="3" halign="right" valign="center" id="Label_Ratio" />
				<quad posn="0.5 -0.5" sizen="4 4" halign="left" valign="center" image="{{{PathCommon}}}Rocket2.dds" hidden="{{{RocketHidden}}}" id="Quad_Ratio" />
			</frame>
			<label posn="{{{-76*S}}} -5 3" sizen="{{{5*S}}} 5" textsize="5" halign="right" valign="center" id="Label_AtkPoints" />
		</frame>
	</frame>
	<frame posn="0 -11.8 3">
		<frame posn="{{{-3.5*S}}} 0">
			<quad posn="0 -0.3" sizen="2.5 2.5" valign="center" image="file://Media/Manialinks/Common/AllyNo.dds" id="Quad_Ally" />
			<label posn="-1 0" sizen="{{{24*S}}} 5" textsize="1" textemboss="1" halign="right" valign="center" id="Label_Rank" />
		</frame>
		<frame posn="{{{-30*S}}} 0" id="Frame_LadderPoints" hidden="1">
			<format textcolor="bb8" textsize="1" />
			<quad posn="-18 -0.2" sizen="5 5" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-23.5 0" sizen="10 5" halign="right" valign="center" id="Label_LadderPoints"/>
			<quad posn="0 -0.2" sizen="5 5" halign="right" valign="center" style="Icons128x128_1" substyle="LadderPoints" />
			<label posn="-5.5 0" sizen="10 5" halign="right" valign="center" id="Label_LadderPointsTotal" />
		</frame>
		<frame posn="{{{-69*S}}} -0.1" id="Frame_Stats">
			<format textcolor="444" textsize="1" />
			<label posn="-6 0.2" sizen="10 5" halign="center" valign="center" opacity="0.3" id="Label_StatsAverage" />
			<quad posn="0 -0.2" sizen="3 3" valign="center" opacity="0.4" image="{{{PathCommon}}}Shield.dds" />
		</frame>
		{{{Tags[2]}}}
	</frame>
</framemodel>
""";
	
	for (J, 1, 2) {
		for (I, 1, PlayersByCol) {
			if (J % 2 == 1) {
				ML ^= """
<frame posn="{{{PosX}}} {{{PosY}}}">
	<quad posn="0 0 -3" sizen="{{{82.25*S}}} 14.1" bgcolor="000c" id="Quad_Player_{{{K}}}" scriptevents="1" />
	<frameinstance modelid="Frame_PlayerLeft" id="Frame_Player_{{{K}}}" />
</frame>
""";
			} else {
				ML ^= """
<frame posn="{{{PosX+(164.5*S/2.)}}} {{{PosY}}}">
	<quad posn="0 0 -3" sizen="{{{82.25*S}}} 14.1" bgcolor="000c" halign="right" id="Quad_Player_{{{K}}}" scriptevents="1" />
	<frameinstance modelid="Frame_PlayerRight" id="Frame_Player_{{{K}}}" />
</frame>
""";
			}
			PosY -= 14.1;
			K += 1;
		}
		PosX += 164.5*S/2.;
		PosY = 0.;
	}
	
	return ML;
***

***CreateLayerScoresTable***
***
declare CW = 1.;
declare SW = 1.;
declare PosY = 41;

declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";
	
return """
<!-- **************** Scores table **************** -->
<quad posn="0 {{{PosY-39}}} -2" sizen="237 104" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_bg.dds" />
<quad posn="-73.5 {{{PosY-27}}} 6" sizen="28 56" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_left.dds" colorize="{{{Team1Color}}}" id="Quad_Clan1Color" />
<quad posn=" 73.5 {{{PosY-27}}} 6" sizen="28 56" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_right.dds" colorize="{{{Team2Color}}}" id="Quad_Clan2Color" />
<quad posn="0 {{{PosY-39.3}}} -5" sizen="166 0" halign="center" valign="center" bgcolor="000f" />
<frame posn="0 {{{PosY}}}" id ="Frame_ScoresTable">
	<format textemboss="1" />
	<!-- **************** VS **************** -->
	<frame posn="0 -11.7" id="Frame_VS">
		<quad posn="-7 -2.5" sizen="15 15" halign="right" valign="bottom" style="Emblems" substyle="#1" />
		<quad posn="7 -2.5" sizen="15 15" valign="bottom" style="Emblems" substyle="#2" />
		<label posn="-46 1" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam1" />
		<label posn=" 46 1" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam2" />
	</frame>
	<!-- **************** Players Ranking **************** -->
	<frame posn="{{{-164.5*CW/2.}}} -18" id="Frame_Ranking">
		{{{CreatePlayersListBig(1, C_RequiredPlayersNb*2, CW)}}}
	</frame>
	<!-- **************** Bottom panels **************** -->
	<frame posn="{{{-164*CW/2.}}} -55.8">
		<!-- **************** Laser stats **************** -->
		<quad posn="{{{1*SW}}} -8.2" sizen="4 4" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<label posn="{{{6*SW}}} -8" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Longest Laser: %1 by %2"), "-", "-")}}}" id="Label_LongestLaser" />
		<!-- **************** Server info **************** -->
		<label posn="{{{158*CW}}} -8" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose("%1: $<%2$>", _("Server"), "-")}}}" id="Label_ServerName" />
		<quad posn="{{{163*SW}}} -8.2" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Home.dds" />
		<!-- **************** Game info **************** -->
		<quad posn="{{{1.5*SW}}} -13.7" sizen="3 3" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Rocket.dds" />
		<label posn="{{{6*SW}}} -13.5" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" id="Label_GameInfo" />
		<label posn="{{{158*CW}}} -13.5" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" id="Label_GoalAverage" />
		<quad posn="{{{163*SW}}} -13.7" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Score.dds" />
	</frame>
</frame>
<!-- **************** Spec count **************** -->
<frame posn="-150 82">
	<label posn="0.5 0.5" valign="center" textemboss="1" text="0" id="Label_SpecCount" />
	<quad sizen="7 7" halign="right" valign="center" style="BgRaceScore2" substyle="Tv" />
</frame>
<script><!--
#Include "TextLib" as TextLib
#Include "MathLib" as ML

#Const C_PlayerCardWidth {{{81.7*CW}}}

declare CMlLabel	Label_NameTeam1;
declare CMlLabel 	Label_NameTeam2;
declare CMlFrame	Frame_Ranking;
declare CMlLabel	Label_LongestLaser;
declare CMlLabel	Label_ServerName;
declare CMlLabel	Label_GameInfo;
declare CMlLabel	Label_GoalAverage;

Text GetEchelonPath(CUser::EEchelon _Echelon, Integer _Side) {
	declare EchelonSide = "";
	if (_Side < 0) EchelonSide = "_rev";
					
	switch (_Echelon) {
		case CUser::EEchelon::Bronze1	: return "file://Media/Manialinks/Common/Echelons/small_echelon1"^EchelonSide^".dds";
		case CUser::EEchelon::Bronze2	: return "file://Media/Manialinks/Common/Echelons/small_echelon2"^EchelonSide^".dds";
		case CUser::EEchelon::Bronze3	: return "file://Media/Manialinks/Common/Echelons/small_echelon3"^EchelonSide^".dds";
		case CUser::EEchelon::Silver1	: return "file://Media/Manialinks/Common/Echelons/small_echelon4"^EchelonSide^".dds";
		case CUser::EEchelon::Silver2	: return "file://Media/Manialinks/Common/Echelons/small_echelon5"^EchelonSide^".dds";
		case CUser::EEchelon::Silver3	: return "file://Media/Manialinks/Common/Echelons/small_echelon6"^EchelonSide^".dds";
		case CUser::EEchelon::Gold1		: return "file://Media/Manialinks/Common/Echelons/small_echelon7"^EchelonSide^".dds";
		case CUser::EEchelon::Gold2		: return "file://Media/Manialinks/Common/Echelons/small_echelon8"^EchelonSide^".dds";
		case CUser::EEchelon::Gold3		: return "file://Media/Manialinks/Common/Echelons/small_echelon9"^EchelonSide^".dds";
	}
	
	return "";
}

Void UpdatePlayersList(
	Integer				_AttackerKey, 
	Text[Integer]		_Logins, 
	Text[Integer]		_Names, 
	Text[Integer]		_Zones,
	Integer[Integer]	_Ranks,
	Real[Integer]		_LadderPoints,
	Real[Integer]		_LadderPointsTotal,
	Boolean[Integer]	_Ready,
	Integer[Integer]	_DefPoints, 
	Integer[Integer]	_AtkPoints,
	Integer				_Mode,
	Integer[Integer]	_Fames,
	Ident[Integer]		_PlayersIds,
	Integer[Integer]	_LaserHit,
	Integer[Integer]	_NbElimination,
	Integer[][Integer]	_Tags_Favored_Indices,
	Text[][Integer]		_Tags_Id,
	CUser::ETagType[][Integer] _Tags_Type
) {	
	for (I, 1, {{{C_RequiredPlayersNb*2}}}) {
		declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I) as CMlFrame);
		
		if (_Logins.existskey(I)) {
			declare Quad_NotReady			<=> (Frame_Player.GetFirstChild("Quad_NotReady")			as CMlQuad);
			declare Quad_Ready				<=> (Frame_Player.GetFirstChild("Quad_Ready")				as CMlQuad);
			declare Quad_Avatar 			<=> (Frame_Player.GetFirstChild("Quad_Avatar")				as CMlQuad);
			declare Quad_Eliminated			<=> (Frame_Player.GetFirstChild("Quad_Eliminated")			as CMlQuad);
			declare Quad_Attacker			<=> (Frame_Player.GetFirstChild("Quad_Attacker")			as CMlQuad);
			declare Label_Name				<=> (Frame_Player.GetFirstChild("Label_Name")				as CMlLabel);
			declare Quad_Echelon			<=> (Frame_Player.GetFirstChild("Quad_Echelon")				as CMlQuad);
			declare Quad_Ally				<=> (Frame_Player.GetFirstChild("Quad_Ally")				as CMlQuad);
			declare Label_Rank				<=> (Frame_Player.GetFirstChild("Label_Rank")				as CMlLabel);
			declare Frame_Stars				<=> (Frame_Player.GetFirstChild("Frame_Stars")				as CMlFrame);			
			declare Label_Ratio				<=> (Frame_Player.GetFirstChild("Label_Ratio")				as CMlLabel);
			declare Quad_Ratio				<=> (Frame_Player.GetFirstChild("Quad_Ratio")				as CMlQuad);
			declare Label_AtkPoints			<=> (Frame_Player.GetFirstChild("Label_AtkPoints")			as CMlLabel);
			declare Frame_Stats				<=> (Frame_Player.GetFirstChild("Frame_Stats")				as CMlFrame);
			declare Label_StatsAverage		<=> (Frame_Stats.GetFirstChild("Label_StatsAverage")		as CMlLabel);
			declare Frame_LadderPoints		<=> (Frame_Player.GetFirstChild("Frame_LadderPoints")		as CMlFrame);
			declare Label_LadderPoints		<=> (Frame_Player.GetFirstChild("Label_LadderPoints")		as CMlLabel);
			declare Label_LadderPointsTotal	<=> (Frame_Player.GetFirstChild("Label_LadderPointsTotal")	as CMlLabel);
			declare Frame_Tags				<=> (Frame_Player.GetFirstChild("Frame_Tags")				as CMlFrame);
			
			declare Side = 1;
			if (Label_Name.RelativePosition.X < 0) Side = -1;
			
			Frame_Player.Show();
			// Ready state
			if (_Mode == {{{C_SequenceWarmUp}}}) {
				Quad_Avatar.RelativePosition.X = {{{4 + (3*CW)}}} * Side;
				Label_Name.RelativePosition.X = {{{12*CW}}} * Side;
				Frame_Stars.RelativePosition.X = {{{64*CW}}} * Side;
				if (_Ready.existskey(I)) {
					if (_Ready[I]) {
						Quad_Ready.Show();
						Quad_NotReady.Hide();
					} else {
						Quad_Ready.Hide();
						Quad_NotReady.Show();
					}
				} else {
					Quad_Ready.Hide();
					Quad_NotReady.Show();
				}
			} else {
				Quad_Avatar.RelativePosition.X = {{{5 + (0*CW)}}} * Side;
				Label_Name.RelativePosition.X = {{{10*CW}}} * Side;
				Frame_Stars.RelativePosition.X = {{{63*CW}}} * Side;
				Quad_Ready.Hide();
				Quad_NotReady.Hide();
			}
			// Avatar
			if (_Logins.existskey(I) && _Names.existskey(I)) {
				Quad_Avatar.ChangeImageUrl("file://Avatars/"^_Logins[I]^"/Default");
			} else {
				Quad_Avatar.ChangeImageUrl("");
			}
			
			// Tags
			if (Frame_Tags != Null) {
				if (_Mode == {{{C_SequencePodium}}}) {
					Frame_Tags.Visible = False;
				} else {
					declare P = 0;
					foreach (Control in Frame_Tags.Controls) {
						if (P > _Tags_Favored_Indices[I].count-1) Control.Visible = False;
						else {
							Control.Visible = True;
							declare Frame_Tag <=> (Control as CMlFrame);
							declare Quad_Medal <=> (Frame_Tag.Controls[0] as CMlQuad);
							declare Quad_Tag <=> (Frame_Tag.Controls[1] as CMlQuad);
							declare TagKey = _Tags_Favored_Indices[I][P];
							Quad_Tag.ImageUrl = "file://Tags/"^_Logins[I]^"/"^_Tags_Id[I][TagKey];
							switch (_Tags_Type[I][TagKey]) {
								case CUser::ETagType::Bronze	: Quad_Medal.Substyle = "TagTypeBronze";
								case CUser::ETagType::Silver	: Quad_Medal.Substyle = "TagTypeSilver";
								case CUser::ETagType::Gold		: Quad_Medal.Substyle = "TagTypeGold";
								case CUser::ETagType::Nadeo		: Quad_Medal.Substyle = "TagTypeNadeo";
								default							: Quad_Medal.Substyle = "TagTypeNone";
							}
						}
						P += 1;
					}
					Frame_Tags.Visible = True;
				}
			}
			
			// Name
			if (_Names.existskey(I)) {
				Label_Name.SetText(_Names[I]);
			} else {
				Label_Name.SetText("-");
			}
			if (_PlayersIds.existskey(I) && Players.existskey(_PlayersIds[I])) {
				declare Player <=> Players[_PlayersIds[I]];
				
				// Echelons				
				declare EchelonPath = GetEchelonPath(Player.User.Echelon, Side);
				if (EchelonPath != "") {
					Quad_Echelon.Show();
					Quad_Echelon.ImageUrl = EchelonPath;
				} else {
					Quad_Echelon.Hide();
				}
				
				// Allies
				declare netread Boolean Net_LayerST_IsAlly for Player;
				if (Net_LayerST_IsAlly) {
					Quad_Ally.ChangeImageUrl("file://Media/Manialinks/Common/AllyYes.dds");
				} else {
					Quad_Ally.ChangeImageUrl("file://Media/Manialinks/Common/AllyNo.dds");
				}
			}
			// Rank
			if (_Ranks.existskey(I) && _Ranks[I] > 0 && _Zones.existskey(I)) {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _Zones[I], TextLib::ToText(_Ranks[I])));
			} else {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Other"), "-"));
			}
			// Stars Fames
			if (_Fames.existskey(I)) {
				declare StarSize = 3.;
				declare Fame = _Fames[I];
				if (Fame > 5) Fame = 5;
				else if (Fame < 0) Fame = 0;
						
				if (Fame > 0 && Fame <= 5) {
					declare Quad_Star_1 <=> (Frame_Stars.GetFirstChild("Quad_Star_1") as CMlQuad);
					declare Quad_Star_2 <=> (Frame_Stars.GetFirstChild("Quad_Star_2") as CMlQuad);
					declare Quad_Star_3 <=> (Frame_Stars.GetFirstChild("Quad_Star_3") as CMlQuad);
					declare Quad_Star_4 <=> (Frame_Stars.GetFirstChild("Quad_Star_4") as CMlQuad);
					declare Quad_Star_5 <=> (Frame_Stars.GetFirstChild("Quad_Star_5") as CMlQuad);
					Frame_Stars.Show();
					Quad_Star_1.Hide();
					Quad_Star_2.Hide();
					Quad_Star_3.Hide();
					Quad_Star_4.Hide();
					Quad_Star_5.Hide();
					
					if (Fame >= 1) Quad_Star_1.Show();
					if (Fame >= 2) Quad_Star_2.Show();
					if (Fame >= 3) Quad_Star_3.Show();
					if (Fame >= 4) Quad_Star_4.Show();
					if (Fame >= 5) Quad_Star_5.Show();
					
					switch(Fame) {
						case 1: {
							Quad_Star_1.RelativePosition.X = -StarSize/2.*Side; Quad_Star_1.RelativePosition.Y = 0.;
						}
						case 2: {
							Quad_Star_1.RelativePosition.X = 0.*Side;			Quad_Star_1.RelativePosition.Y = 0.;
							Quad_Star_2.RelativePosition.X = -StarSize*Side;	Quad_Star_2.RelativePosition.Y = 0.;
						}
						case 3: {
							Quad_Star_1.RelativePosition.X = 0.*Side;			Quad_Star_1.RelativePosition.Y = -StarSize/2.;
							Quad_Star_2.RelativePosition.X = -StarSize*Side;	Quad_Star_2.RelativePosition.Y = -StarSize/2.;
							Quad_Star_3.RelativePosition.X = -StarSize/2.*Side;	Quad_Star_3.RelativePosition.Y = StarSize/2.;
						}
						case 4: {
							Quad_Star_1.RelativePosition.X = 0.*Side;			Quad_Star_1.RelativePosition.Y = -StarSize/2.;
							Quad_Star_2.RelativePosition.X = -StarSize*Side;	Quad_Star_2.RelativePosition.Y = -StarSize/2.;
							Quad_Star_3.RelativePosition.X = 0.*Side;			Quad_Star_3.RelativePosition.Y = StarSize/2.;
							Quad_Star_4.RelativePosition.X = -StarSize*Side;	Quad_Star_4.RelativePosition.Y = StarSize/2.;
						}
						case 5: {
							Quad_Star_1.RelativePosition.X = 0.*Side;			Quad_Star_1.RelativePosition.Y = -StarSize/2.;
							Quad_Star_2.RelativePosition.X = -StarSize*Side;	Quad_Star_2.RelativePosition.Y = -StarSize/2.;
							Quad_Star_3.RelativePosition.X = 0.*Side;			Quad_Star_3.RelativePosition.Y = StarSize/2.;
							Quad_Star_4.RelativePosition.X = -StarSize*Side;	Quad_Star_4.RelativePosition.Y = StarSize/2.;
							Quad_Star_5.RelativePosition.X = -StarSize*0.5*Side;Quad_Star_5.RelativePosition.Y = 0.;
						}
					}
				} else {
					Frame_Stars.Hide();
				}
			} else {
				Frame_Stars.Hide();
			}
			// Stats
			declare HasHit = 0;
			declare IsHit = 0;
			if (_LaserHit.existskey(I)) {
				HasHit += _LaserHit[I];
			}
			if (_DefPoints.existskey(I)) {
				HasHit += _DefPoints[I];
			}
			if (_NbElimination.existskey(I)) {
				IsHit = _NbElimination[I];
			}
			Label_StatsAverage.SetText("+"^HasHit^" / -"^IsHit);
			// DefPoints
			if (_DefPoints.existskey(I)) {
				Label_Ratio.SetText(""^_DefPoints[I]);
			} else {
				Label_Ratio.SetText("0");
			}
			// AtkPoints
			if (_AtkPoints.existskey(I)) {
				Label_AtkPoints.SetText(""^_AtkPoints[I]);
			} else {
				Label_AtkPoints.SetText("0");
			}
			// Attacker
			if (I == _AttackerKey && _Mode == {{{C_SequencePlaying}}}) {
				Quad_Attacker.Show();
			} else {
				Quad_Attacker.Hide();
			}
			
			// Ladder points
			if (_Mode == {{{C_SequencePodium}}} && _LadderPoints.existskey(I) && _LadderPoints[I] != -1.) {
				Frame_LadderPoints.Show();
				
				declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(_LadderPoints[I]));
				declare LadderPoints = "0.0";
				if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
				if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);
				
				if (_LadderPoints[I] >= 0) Label_LadderPoints.SetText("+"^LadderPoints);
				else Label_LadderPoints.SetText(LadderPoints);
				
				if (_LadderPointsTotal.existskey(I)) {
					declare LadderPointsTotalExplode = TextLib::Split(".", TextLib::ToText(_LadderPointsTotal[I]));
					declare LadderPointsTotal = "0";
					if (LadderPointsTotalExplode.existskey(0)) LadderPointsTotal = LadderPointsTotalExplode[0];
					Label_LadderPointsTotal.SetText(LadderPointsTotal);
				} else {
					Label_LadderPointsTotal.SetText("0");
				}
			} else {
				Frame_LadderPoints.Hide();
			}
		} else {
			Frame_Player.Hide();
		}
	}
}

Void UpdateStats(
	Text[Integer]		_Names,
	Real[Integer]		_LaserLongest,
	Integer[Integer]	_LaserHit,
	Integer[Integer]	_LaserShot
) {	
	declare LaserLongest = Real[Integer];
	foreach (Key => Distance in _LaserLongest) {
		if (Distance > 0.) LaserLongest[Key] = Distance * -1.;
	}
	LaserLongest = LaserLongest.sort();
	
	/*declare LaserAccuracy = Real[Integer];
	foreach (Key => Nb in _LaserShot) {
		if (Nb > 0 && _LaserHit.existskey(Key) && _LaserHit[Key] > 0) {
			LaserAccuracy[Key] = ((_LaserHit[Key] * 1.) / (Nb * 1.)) * -100.;
		}
	}
	LaserAccuracy = LaserAccuracy.sort();*/
	
	declare Longest = "-";
	declare LongestName = "-";
	declare Accuracy = "-";
	declare AccuracyName = "-";
	
	foreach (Key => Distance in LaserLongest) {
		Longest = TextLib::SubString(TextLib::ToText(Distance*-1.), 0, 5)^"m";
		if (_Names.existskey(Key)) LongestName = "$<"^_Names[Key]^"$>";
		break;
	}
	
	/*foreach (Key => Percentage in LaserAccuracy) {
		Accuracy = _LaserHit[Key]^"/"^_LaserShot[Key]^" ("^TextLib::SubString(TextLib::ToText(Percentage*-1.), 0, 5)^"%)";
		if (_Names.existskey(Key)) AccuracyName = _Names[Key];
		break;
	}*/
	
	Label_LongestLaser.SetText(TextLib::Compose(_("Longest Laser: %1 by %2"), Longest, LongestName));
}

Void UpdateGameInfo(Integer _PointsLimit, Integer _PointsToWin) {
	Label_GoalAverage.SetText(TextLib::Compose(
		"%1 %2 / %3 %4", 
		_("Points limit : "), 
		TextLib::ToText(_PointsLimit), 
		_("Max points :"), 
		TextLib::ToText(_PointsToWin)
	));
}

Void UpdateDodge() {
	declare netread Integer Net_Elite_BestDodgeTotal for Teams[0];
	declare netread Text Net_Elite_BestDodgeName for Teams[0];
	declare Dodge = "-";
	declare Name = "-";
	
	if (Net_Elite_BestDodgeTotal > 0) Dodge = TextLib::ToText(Net_Elite_BestDodgeTotal);
	if (Net_Elite_BestDodgeName != "") Name = Net_Elite_BestDodgeName;
	
	Label_GameInfo.SetText(TextLib::Compose(_("Most dodge : %1 by %2"), Dodge, Name));
}

Void UpdatePlayersStatus(Boolean _Forced) {
	declare netread Text[Integer] Net_LayerST_Logins for UI;
	
	foreach (Player in Players) {
		declare PrevSpawnStatus for Player = CSmPlayer::ESpawnStatus::Spawned;
		if (PrevSpawnStatus != Player.SpawnStatus || _Forced) {
			PrevSpawnStatus = Player.SpawnStatus;
			
			if (!Net_LayerST_Logins.exists(Player.Login)) continue;
			
			declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^Net_LayerST_Logins.keyof(Player.Login)) as CMlFrame);
			if (Frame_Player == Null) continue;
			
			declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated")	as CMlQuad);
			declare Quad_Armors		<=> (Frame_Player.GetFirstChild("Quad_Armors")		as CMlGauge);
			declare netread Integer Net_LayerST_Mode for UI;
			
			if (Net_LayerST_Mode == {{{C_SequencePlaying}}} && UI.UISequence == CUIConfig::EUISequence::Playing) {
				if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					Quad_Eliminated.Show();
					Quad_Armors.SetRatio(0.);
				} else {
					Quad_Eliminated.Hide();
					if (Player.ArmorMax > 0) {
						declare Ratio = ML::ToReal(Player.Armor) / ML::ToReal(Player.ArmorMax);
						if (Ratio >= 1.) Ratio = 0.989; ///< Avoid the bright white in the bar when ratio = 1.
						Quad_Armors.SetRatio(Ratio);
					} else {
						Quad_Armors.SetRatio(0.);
					}
				}
			} else {
				Quad_Eliminated.Hide();
				Quad_Armors.SetRatio(0.);
			}
		}
	}
}

main() {
	Label_NameTeam1			<=> (Page.GetFirstChild("Label_NameTeam1")		as CMlLabel);
	Label_NameTeam2			<=> (Page.GetFirstChild("Label_NameTeam2")		as CMlLabel);
	Frame_Ranking			<=> (Page.GetFirstChild("Frame_Ranking")		as CMlFrame);
	Label_LongestLaser		<=> (Page.GetFirstChild("Label_LongestLaser")	as CMlLabel);
	Label_ServerName		<=> (Page.GetFirstChild("Label_ServerName")		as CMlLabel);
	Label_GameInfo			<=> (Page.GetFirstChild("Label_GameInfo")		as CMlLabel);
	Label_GoalAverage		<=> (Page.GetFirstChild("Label_GoalAverage")	as CMlLabel);
	declare Label_SpecCount	<=> (Page.GetFirstChild("Label_SpecCount")		as CMlLabel);
	declare Quad_Clan1Color	<=> (Page.GetFirstChild("Quad_Clan1Color")		as CMlQuad);
	declare Quad_Clan2Color	<=> (Page.GetFirstChild("Quad_Clan2Color")		as CMlQuad);
	
	declare netread Integer				Net_LayerST_Update			for UI;
	declare netread Integer				Net_LayerST_AttackerKey		for UI;
	declare netread Text[Integer]		Net_LayerST_Logins			for UI;
	declare netread Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netread Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netread Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netread Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netread	Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netread Integer				Net_LayerST_PointsLimit		for UI;
	declare netread Integer				Net_LayerST_PointsToWin		for UI;
	declare netread Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netread Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netread Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netread Integer				Net_LayerST_Mode			for UI;
	declare netread Integer[Integer]	Net_LayerST_NbBeHit			for UI;
	declare netread Integer 			Net_Elite_BestDodgeTotal 	for Teams[0];
	
	declare Text[Integer]		Logins;
	declare Text[Integer]		Names;
	declare Integer[Integer]	LadderRanks;
	declare Text[Integer]		Zones;
	declare Integer				Order;
	declare Real[Integer]		LadderPoints;
	declare Real[Integer]		LadderPointsTotal;
	declare Integer[Integer]	Fames;
	declare Ident[Integer]		PlayersIds;
	declare Integer[][Integer]	Tags_Favored_Indices;
	declare Text[][Integer]		Tags_Id;
	declare CUser::ETagType[][Integer] Tags_Type;
	
	declare LastUpdate = -1;
	declare PrevUISequence = CUIConfig::EUISequence::None;
	declare PrevServerName = "";
	declare PrevSpecCount = 0;
	declare PrevClan1Name = "";
	declare PrevClan2Name = "";
	declare PrevClan1Color = <0., 0., 1.>;
	declare PrevClan2Color = <1., 0., 0.>;
	declare PrevBestDodgeTotal = -1;

	while (True) {
		yield;
		
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		if (PrevServerName != CurrentServerName) {
			PrevServerName = CurrentServerName;
			Label_ServerName.SetText(TextLib::Compose("%1: $<%2$>", _("Server"), CurrentServerName));
		}
		
		if (PrevClan1Name != Teams[0].ColorizedName) {
			PrevClan1Name = Teams[0].ColorizedName;
			if (Teams[0].ColorizedName == "$<$00fBlue$>") Label_NameTeam1.SetText("$<$fffBlue$>");
			else Label_NameTeam1.SetText(Teams[0].ColorizedName);
		}
		if (PrevClan2Name != Teams[1].ColorizedName) {
			PrevClan2Name = Teams[1].ColorizedName;
			if (Teams[1].ColorizedName == "$<$f00Red$>") Label_NameTeam2.SetText("$<$fffRed$>");
			else Label_NameTeam2.SetText(Teams[1].ColorizedName);
		}
		if (PrevClan1Color != Teams[0].ColorPrimary) {
			PrevClan1Color = Teams[0].ColorPrimary;
			Quad_Clan1Color.Colorize = Teams[0].ColorPrimary;
		}
		if (PrevClan2Color != Teams[1].ColorPrimary) {
			PrevClan2Color = Teams[1].ColorPrimary;
			Quad_Clan2Color.Colorize = Teams[1].ColorPrimary;
		}
		
		if (PrevBestDodgeTotal != Net_Elite_BestDodgeTotal) {
			PrevBestDodgeTotal = Net_Elite_BestDodgeTotal;
			UpdateDodge();
		}
		
		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;
			
			UpdatePlayersStatus(True);
			
			Logins = Net_LayerST_Logins;
			for (I, 1, {{{C_RequiredPlayersNb*2}}}) {
				declare Frame_Player <=> Frame_Ranking.GetFirstChild("Quad_Player_"^I);
				if (Frame_Player == Null) continue;
				declare SpectateLogin for Frame_Player = "";
				if (!Logins.existskey(I)) SpectateLogin = "";
				else SpectateLogin = Logins[I];				
			}
			
			if (Net_LayerST_AttackerKey <= 0) Order = -1;
			else if (Net_LayerST_AttackerKey <= 3) Order = Net_LayerST_AttackerKey;
			else Order = Net_LayerST_AttackerKey - 3;
			
			Names.clear();
			LadderRanks.clear();
			foreach (Score in Scores) {
				if (Logins.exists(Score.User.Login)) {
					declare Key = Logins.keyof(Score.User.Login);
					Names[Key] = Score.User.Name;
					LadderRanks[Key] = Score.User.LadderRank;
					LadderPoints[Key] = Score.LadderScore;
					LadderPointsTotal[Key] = Score.User.LadderPoints;
					Fames[Key] = Score.User.FameStars;
					Tags_Favored_Indices[Key] = Integer[];
					foreach (Indice in Score.User.Tags_Favored_Indices) {
						Tags_Favored_Indices[Key].add(Indice);
					}
					Tags_Id[Key] = Text[];
					foreach (Id in Score.User.Tags_Id) {
						Tags_Id[Key].add(Id);
					}
					Tags_Type[Key] = CUser::ETagType[];
					foreach (Type in Score.User.Tags_Type) {
						Tags_Type[Key].add(Type);
					}
					
					declare ZonePath = "";
					if (Score.User.ZonePath != "") {
						declare ExplodeZonePath = TextLib::Split("|", Score.User.ZonePath);
						if (ExplodeZonePath.existskey(1)) ZonePath = ExplodeZonePath[1];
					}
					Zones[Key] = ZonePath;
				}
			}
			foreach (Player in Players) {
				if (Logins.exists(Player.Login)) {
					declare Key = Logins.keyof(Player.Login);
					PlayersIds[Key] = Player.Id;
				}
			}
			
			UpdatePlayersList(
				Net_LayerST_AttackerKey, 
				Logins, 
				Names, 
				Zones,
				LadderRanks,
				LadderPoints,
				LadderPointsTotal,
				Net_LayerST_Ready, 
				Net_LayerST_DefPoints, 
				Net_LayerST_AtkPoints,
				Net_LayerST_Mode,
				Fames,
				PlayersIds,
				Net_LayerST_LaserHit,
				Net_LayerST_NbBeHit,
				Tags_Favored_Indices,
				Tags_Id,
				Tags_Type
			);
			
			UpdateStats(
				Names,
				Net_LayerST_LaserLongest,
				Net_LayerST_LaserHit,
				Net_LayerST_LaserShot
			);
			
			UpdateGameInfo(
				Net_LayerST_PointsLimit,
				Net_LayerST_PointsToWin
			);
		}
		
		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;
			
			if (UI.UISequence != CUIConfig::EUISequence::Playing) {
				for (I, 1, {{{C_RequiredPlayersNb*2}}}) {
					declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I)	as CMlFrame);
					declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
					Quad_Eliminated.Hide();
				}
			}
			
			UpdatePlayersStatus(True);
		}
		
		if (UI.UISequence == CUIConfig::EUISequence::Playing) UpdatePlayersStatus(False);
		
		declare SpecCount = 0;
		foreach (Player in Players) {
			if (Player.User.RequestsSpectate) SpecCount += 1;
		}
		if (PrevSpecCount != SpecCount) {
			PrevSpecCount = SpecCount;
			Label_SpecCount.SetText(TextLib::ToText(SpecCount));
		}
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (IsSpectatorMode) {
					declare SpectateLogin for Event.Control = "";
					if (SpectateLogin != "") SetSpectateTarget(SpectateLogin);
				}
			}
		}
	}
}
--></script>
""";
***

***UpdateLayerScoresTable***
***
declare Logins			= Text[Integer];
declare AttackerKey		= -1;
declare AtkPoints		= Integer[Integer];
declare DefPoints		= Integer[Integer];
declare LasersLongest	= Real[Integer];
declare LasersHit		= Integer[Integer];
declare LasersShot		= Integer[Integer];
declare Eliminations	= [0 => 0];
declare ReadyState		= Boolean[Integer];
declare NbBeHits		= Integer[Integer];

declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
for (I, 1, 2) {
	declare J = 1;
	foreach (Slot => Id in ClansOrders[I]) {
		if (Players.existskey(Id)) {
			declare Key = J+((I-1)*C_RequiredPlayersNb);
			declare Player <=> Players[Id];
			Logins[Key] = Player.Login;
			if (Id == G_AtkPlayerId) AttackerKey = Key;
			if (Player.Score != Null) {
				declare NbHit for Player.Score = 0;
				declare LaserLongest for Player.Score = 0.;
				declare LaserHit for Player.Score = 0;
				declare LaserShot for Player.Score = 0;
				declare NbBeHit for Player.Score = 0;
				AtkPoints[Key] = Player.Score.Points;
				DefPoints[Key] = NbHit;
				LasersLongest[Key] = LaserLongest;
				LasersHit[Key] = LaserHit;
				LasersShot[Key] = LaserShot;
				NbBeHits[Key] = NbBeHit;
			}
			ReadyState[Key] = WarmUp2::IsReady(Player);
			
			declare netwrite Boolean Net_LayerST_IsAlly as Ally1 for Player;
			declare Integer AllyUpdate as AllyUpdate1 for Player;
			if (AllyUpdate1 != Now) Ally1 = False;
			AllyUpdate1 = Now;
			for (K, J+1, C_RequiredPlayersNb) {
				if (ClansOrders.existskey(I) && Players.existskey(ClansOrders[I][K])) {
					declare Player2 <=> Players[ClansOrders[I][K]];
					if (Users_AreAllies(Player.User, Player2.User)) {
						declare netwrite Boolean Net_LayerST_IsAlly as Ally2 for Player2;
						declare Integer AllyUpdate as AllyUpdate2 for Player2;
						Ally1 = True;
						Ally2 = True;
						AllyUpdate2 = Now;
					}
				}
			}
			// Matchmaking temp allies
			if (!Ally1 && G_TempAllies.exists(Player.Login)) {
				Ally1 = True;
			}
		}
		J += 1;
	}
}

if (G_TieBreak) Eliminations = [1 => G_TieBreakDefElim[1], 2 => G_TieBreakDefElim[2]];

foreach (Player in AllPlayers) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	declare netwrite Integer			Net_LayerST_Update			for UI;
	declare netwrite Integer			Net_LayerST_AttackerKey		for UI;
	declare netwrite Text[Integer]		Net_LayerST_Logins			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netwrite Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netwrite Integer			Net_LayerST_PointsLimit		for UI;
	declare netwrite Integer			Net_LayerST_PointsToWin		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netwrite Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netwrite Integer			Net_LayerST_Mode			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_NbBeHit			for UI;
	
	Net_LayerST_Update			= Now;
	Net_LayerST_AttackerKey		= AttackerKey;
	Net_LayerST_Logins			= Logins;
	Net_LayerST_AtkPoints		= AtkPoints;
	Net_LayerST_DefPoints		= DefPoints;
	Net_LayerST_LaserLongest	= LasersLongest;
	Net_LayerST_LaserShot		= LasersShot;
	Net_LayerST_LaserHit		= LasersHit;
	Net_LayerST_PointsLimit		= S_TurnWin;
	Net_LayerST_PointsToWin		= GetPointLimit();
	Net_LayerST_Turns			= [1 => G_MatchPoints[1], 2 => G_MatchPoints[2]];
	Net_LayerST_Eliminations	= Eliminations;
	Net_LayerST_Ready			= ReadyState;
	Net_LayerST_Mode			= _Mode;
	Net_LayerST_NbBeHit			= NbBeHits;
}
***

***StartWarmUp***
***
Interface::CreatePlayersLists("Medium", 0.67, 10, 1);

WarmUp2::SetAllSlotsIcons("Clan1", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
WarmUp2::SetAllSlotsIcons("Clan2", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
WarmUp2::SetSlotIcon("Clan1", G_AtkSlot[1], "file://Media/Manialinks/ShootMania/Common/Laser.dds");
WarmUp2::SetSlotIcon("Clan2", G_AtkSlot[2], "file://Media/Manialinks/ShootMania/Common/Laser.dds");
***

***EndWarmUp***
***
Interface::DestroyPlayersLists();
***

***LadderPoints***
***
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	PrevPoints = Score.Points;
	declare NbHit for Score = 0;
	declare LaserHit for Score = 0;
	declare NbBeHit for Score = 0;
	declare GoalAverage = ((NbHit + LaserHit) / 3.) - (NbBeHit / 6.);
	if (GoalAverage < 0.) GoalAverage = 0.;
	Score.LadderMatchScoreValue = Score.Points + GoalAverage;
	// Winner
	if (Score.LadderClan == WinnerMapClan) {
		Score.Points = 3;
	}
	// Looser
	else if (Score.LadderClan == 3 - WinnerMapClan) {
		Score.Points = 2;
	}
	// Other
	else {
		Score.Points = 0;
		Score.LadderMatchScoreValue = 0.;
	}
}
Ladder_SetResultsVersion(1);
Score::MatchEnd(True);
foreach (Score in Scores) {
	declare PrevPoints for Score = 0;
	Score.Points = PrevPoints;
}
***

***FindMaster***
***
declare MasterLogin = "";
declare BestAtk = 0;
declare BestGoalAverage = 0.;
declare BestHit = 0;
declare BestLP = 0.;
foreach (Score in Scores) {
	declare NbHit for Score = 0;
	declare LaserHit for Score = 0;
	declare NbBeHit for Score = 0;
	declare GoalAverage = ((NbHit + LaserHit) / 3.) - (NbBeHit / 6.);
	declare Hit = NbHit + LaserHit;
	
	if (MasterLogin == "" || Score.Points > BestAtk) {
		MasterLogin = Score.User.Login;
		BestAtk = Score.Points;
		BestGoalAverage = GoalAverage;
		BestHit = Hit;
		BestLP = Score.User.LadderPoints;
	} else if (Score.Points == BestAtk) {
		if (GoalAverage > BestGoalAverage) {
			MasterLogin = Score.User.Login;
			BestAtk = Score.Points;
			BestGoalAverage = GoalAverage;
			BestHit = Hit;
			BestLP = Score.User.LadderPoints;
		} else if (GoalAverage == BestGoalAverage) {
			if (Hit > BestHit) {
				MasterLogin = Score.User.Login;
				BestAtk = Score.Points;
				BestGoalAverage = GoalAverage;
				BestHit = Hit;
				BestLP = Score.User.LadderPoints;
			} else if (Hit == BestHit) {
				if (Score.User.LadderPoints > BestLP) {
					MasterLogin = Score.User.Login;
					BestAtk = Score.Points;
					BestGoalAverage = GoalAverage;
					BestHit = Hit;
					BestLP = Score.User.LadderPoints;
				}
			}
		}
	}
}
//if (MB_UseScriptCallbacks) {
	XmlRpc.SendCallbackArray("Master", [MasterLogin]);
//}
***

***RegisterStats***
***
declare AtkVictory = False;
declare DefNb = 0;
declare AtkArmorNb = 0;

if (WinType == C_WinCapture || WinType == C_WinDefenseEliminated) AtkVictory = True;
if (ClansNbPlayersAlive.existskey(G_DefClan)) DefNb = ClansNbPlayersAlive[G_DefClan];
if (WinType == C_WinAttackEliminated) AtkArmorNb = 0;
else if (Players.existskey(G_AtkPlayerId)) AtkArmorNb = Players[G_AtkPlayerId].Armor / 100;

//if (Players.existskey(G_AtkPlayerId)) EliteStats::RegisterRound(Players[G_AtkPlayerId], AtkVictory, AtkArmorNb, DefNb);
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Create the info layer
 *
 *	@return 	The manialink used by the info layer
 */
Text CreateLayerInfo() {
	declare ImgPath = "file://Media/Manialinks/Shootmania/Common/";
	declare ImgPathElite = "file://Media/Manialinks/Shootmania/Elite/";
	declare ImgCheck = ImgPath^"CheckpointsLeft.dds";
	declare ImgArmor = ImgPath^"AttackerShieldLeft.dds";
	declare CheckpointHidden = 1;
	if (G_CheckpointsNb > 0) CheckpointHidden = 0;

	return """
<frame id="Frame_Playing">
	<frame class="LibCustomUI_Module" id="Elite_Checkpoints">
		<frame posn="156 -80" hidden="{{{CheckpointHidden}}}" scale="0.7" id="Frame_Checkpoints">
			<quad sizen="8 8" halign="right" valign="bottom" image="{{{ImgCheck}}}" colorize="0.5 0.5 0.5" />
			<label posn="-10 4.1" textsize="5" halign="right" valign="center" textemboss="1" textcolor="ddd" text="0/{{{G_CheckpointsNb}}}" id="Label_Checkpoints" />
		</frame>
	</frame>
	<frame class="LibCustomUI_Module" id="Elite_AtkArmor">
		<frame posn="156 -88" scale="0.8" id="Frame_AtkArmor">
			<quad sizen="8 8" halign="right" valign="bottom" image="{{{ImgArmor}}}" colorize="0.5 0.5 0.5" />
			<label posn="-10 4.5" textsize="5" halign="right" valign="center" textemboss="1" textcolor="ddd" text="3" id="Label_ArmorsLeft" />
		</frame>
	</frame>
	<frame class="LibCustomUI_Module" id="Elite_GaugeCapture">
		<frame posn="0 -40" hidden="1" id="Frame_Capture">
			<label posn="0 6" halign="center" textsize="5" textemboss="1" text="100%" id="Label_Capture" />
			<gauge posn="0 0" sizen="140 8" halign="center" style="EnergyBar" drawbg="1" drawblockbg="1" id="Gauge_Capture" />
		</frame>
	</frame>
	<frame class="LibCustomUI_Module" id="Elite_Sponsors">
		<frame posn="90 -88" hidden="1" id="Frame_Sponsors">
			<quad sizen="40 20" valign="bottom" id="Quad_Sponsor" />
		</frame>
	</frame>
</frame>
<!--<quad posn="0 -94 -15" sizen="320 40" halign="center" valign="bottom" image="{{{ImgPathElite}}}BackgroundBottom.dds" />-->
<script><!--
#Include "MathLib" as ML

#Const C_SponsorTime 5000

declare CMlFrame Frame_Sponsors;

Void UpdateSponsorsVisibility() {
	declare netread Text Net_Elite_AtkLogin for Teams[0];
	
	if (
		IsSpectatorMode
		&& GUIPlayer != Null 
		&& Net_Elite_AtkLogin != "" 
		&& GUIPlayer.Login == Net_Elite_AtkLogin
	) {
		Frame_Sponsors.Show();
	} else {
		Frame_Sponsors.Hide();
	}
}

Void UpdateSponsorImage(Integer _Key) {
	declare Quad_Sponsor <=> (Page.GetFirstChild("Quad_Sponsor") as CMlQuad);
	declare netread Text[] Net_Elite_AtkSponsors for Teams[0];
	
	if (!Net_Elite_AtkSponsors.existskey(_Key)) return;
	
	declare Url = Net_Elite_AtkSponsors[_Key];
	if (Http.IsValidUrl(Url)) Quad_Sponsor.ChangeImageUrl(Url);
}

main() {
	declare Frame_Playing		<=> (Page.GetFirstChild("Frame_Playing")		as CMlFrame);
	declare Label_Checkpoints	<=> (Page.GetFirstChild("Label_Checkpoints")	as CMlLabel);
	declare Frame_Capture 		<=> (Page.GetFirstChild("Frame_Capture") 		as CMlFrame);
	declare Label_Capture 		<=> (Page.GetFirstChild("Label_Capture") 		as CMlLabel);
	declare Gauge_Capture 		<=> (Page.GetFirstChild("Gauge_Capture") 		as CMlGauge);
	declare Frame_AtkArmor		<=> (Page.GetFirstChild("Frame_AtkArmor")		as CMlFrame);
	declare Label_ArmorsLeft 	<=> (Page.GetFirstChild("Label_ArmorsLeft") 	as CMlLabel);
	
	Frame_Sponsors <=> (Page.GetFirstChild("Frame_Sponsors") as CMlFrame);
	
	declare netread Integer Net_Elite_CheckpointsCaptured for Teams[0];
	declare netread Text Net_Elite_AtkLogin for Teams[0];
	declare netread Text[] Net_Elite_AtkSponsors for Teams[0];
	declare netread Integer Net_Elite_AtkArmorsLeft for Teams[0];
	
	declare PrevUISequence = CUIConfig::EUISequence::Playing;
	declare PrevCheckpointsCaptured = 0;
	declare PrevGUIPlayerId = NullId;
	declare PrevIsSpectatorMode = False;
	declare PrevAtkArmorsLeft = -1;
	
	declare SponsorKey = 0;
	declare NextSponsorTime = 0;
	
	{{{CustomUI::InjectMLInit()}}}
	
	while (True) {
		yield;
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;
			
			if (UI.UISequence == CUIConfig::EUISequence::Playing || UI.UISequence == CUIConfig::EUISequence::UIInteraction) {
				Frame_Playing.Show();
			} else {
				Frame_Playing.Hide();
			}
		}
		
		if (PrevCheckpointsCaptured != Net_Elite_CheckpointsCaptured) {
			PrevCheckpointsCaptured = Net_Elite_CheckpointsCaptured;
			Label_Checkpoints.SetText(Net_Elite_CheckpointsCaptured^"/{{{G_CheckpointsNb}}}");
		}
		
		if (PrevAtkArmorsLeft != Net_Elite_AtkArmorsLeft) {
			PrevAtkArmorsLeft = Net_Elite_AtkArmorsLeft;
			Label_ArmorsLeft.Value = ""^Net_Elite_AtkArmorsLeft;
		}
		
		if (GUIPlayer != Null && PrevGUIPlayerId != GUIPlayer.Id) {
			PrevGUIPlayerId = GUIPlayer.Id;
			NextSponsorTime = Now + C_SponsorTime;
			UpdateSponsorsVisibility();
			UpdateSponsorImage(SponsorKey);
		} else if (GUIPlayer == Null && Frame_Sponsors.Visible) {
			PrevGUIPlayerId = NullId;
			Frame_Sponsors.Hide();
		}
		
		if (PrevIsSpectatorMode != IsSpectatorMode) {
			PrevIsSpectatorMode = IsSpectatorMode;
			NextSponsorTime = Now + C_SponsorTime;
			UpdateSponsorsVisibility();
			UpdateSponsorImage(SponsorKey);
		}
		
		if (Frame_Sponsors.Visible && Now >= NextSponsorTime) {
			NextSponsorTime = Now + C_SponsorTime;
			if (Net_Elite_AtkSponsors.count > 0 && Net_Elite_AtkSponsors.existskey(0)) {
				SponsorKey += 1;
				if (!Net_Elite_AtkSponsors.existskey(SponsorKey)) SponsorKey = 0;
				UpdateSponsorImage(SponsorKey);
			}
		}
		
		declare CSmPlayer TargetPlayer;
		if (GUIPlayer != Null) TargetPlayer <=> GUIPlayer;
		else TargetPlayer <=> InputPlayer;
		
		if (IsSpectatorMode) {
			declare MaxValueReal = 0.;
			declare Clan = 0;
			foreach (LandmarkGauge in MapLandmarks_Gauge) {
				if (LandmarkGauge.Tag == "Checkpoint" || LandmarkGauge.Gauge.Speed <= 0) continue;
				if (LandmarkGauge.Gauge.ValueReal > MaxValueReal) {
					MaxValueReal = LandmarkGauge.Gauge.ValueReal;
					Clan = LandmarkGauge.Gauge.Clan;
				}
			}
			if (MaxValueReal > 0.) {
				if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
				Gauge_Capture.Ratio = MaxValueReal;
				Gauge_Capture.Clan = Clan;
				Label_Capture.Value = ML::FloorInteger(MaxValueReal * 100.)^"%";
			} else if (Frame_Capture.Visible) {
				Frame_Capture.Visible = False;
			}
		} else {
			if (
				TargetPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned
				&& TargetPlayer.CapturedLandmark != Null 
				&& TargetPlayer.CapturedLandmark.Tag != "Checkpoint"
				&& TargetPlayer.CapturedLandmark.Gauge != Null
				&& TargetPlayer.CapturedLandmark.Gauge.Speed > 0 
			) {
				if (!Frame_Capture.Visible) Frame_Capture.Visible = True;
				Gauge_Capture.Ratio = TargetPlayer.CapturedLandmark.Gauge.ValueReal;
				Gauge_Capture.Clan = TargetPlayer.CapturedLandmark.Gauge.Clan;
				Label_Capture.Value = ML::FloorInteger(TargetPlayer.CapturedLandmark.Gauge.ValueReal * 100.)^"%";
			} else if (Frame_Capture.Visible) {
				Frame_Capture.Visible = False;
			}
		}
	}
}
--></script>
""";
}

// ---------------------------------- //
// Update the info layer
Void UpdateLayerInfo() {
	declare netwrite Net_Elite_CheckpointsCaptured for Teams[0] = 0;
	Net_Elite_CheckpointsCaptured = G_CheckpointsCapturedNb;
}

// ---------------------------------- //
/** Create the replay layer
 *
 *	@return 	The manialink used by the replay layer
 */
// @UIReplay > 
Text CreateLayerReplay() {
	declare PlayersLists = [1 => "", 2 => ""];
	declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	declare ImgPath = "file://Media/Manialinks/Shootmania/Common/";
	
	for (I, 1, 2) {
		declare First = True;
		foreach (Slot => Id in ClansOrders[I]) {
			if (Players.existskey(Id)) {
				declare Player <=> Players[Id];
				
				declare Side = 1;
				declare Align = "left";
				if (I == 2) {
					Side = -1;
					Align = "right";
				}
				PlayersLists[I] ^= """
<quad posn="0 {{{-2+(-4.5*(Slot-1))}}}" sizen="39.70 4" halign="{{{Align}}}" valign="center" bgcolor="0007" />
<label posn="{{{1*Side}}} {{{-2+(-4.5*(Slot-1))}}} 1" sizen="38 4" halign="{{{Align}}}" valign="center2" text="{{{Player.Name}}}" />""";
				
				declare Weapon = "";
				declare netwrite Integer[] Net_Elite_HitDetail for Player;
				declare Count = 0;
				foreach (Hit in Net_Elite_HitDetail) {
					switch (Hit) {
						case GetWeaponNum(CSmMode::EWeapon::Laser): Weapon = "WpLaser.dds";
						case GetWeaponNum(CSmMode::EWeapon::Rocket): Weapon = "WpRocket.dds";
						case GetWeaponNum(CSmMode::EWeapon::Nucleus): Weapon = "WpNucleus.dds";
						case GetWeaponNum(CSmMode::EWeapon::Arrow): Weapon = "WpArrows.dds";
					}
					PlayersLists[I] ^= """
<quad posn="{{{(40 + (Count*4))*Side}}} {{{-1.8+(-4.5*(Slot-1))}}}" sizen="3.5 3.5" halign="{{{Align}}}" valign="center" image="{{{ImgPath}}}{{{Weapon}}}" colorize="0.5 0.5 0.5" />""";
					Count += 1;
				}
			}
		}
	}
	
	return """
<frame posn="0 92">
	<frame id="Frame_Scores">
		<quad sizen="20 10" halign="right" style="UiSMSpectatorScoreBig" substyle="HandleLeft" />
		<label posn="-5 -2.5" scale="0.4" halign="right" style="TextRaceMessageBig" text="{{{UIManager.UIAll.ScoreSummary_Points1}}}" />
		<quad sizen="20 10" halign="left" style="UiSMSpectatorScoreBig" substyle="HandleRight" />
		<label posn="5 -2.5" scale="0.4" halign="left" style="TextRaceMessageBig" text="{{{UIManager.UIAll.ScoreSummary_Points2}}}" />
	</frame>
	<frame posn="0 -18" id="Frame_PlayersLists">
		<frame posn="-160 0" id="Frame_PlayersList_1">
			<frame id="Frame_TeamName_1">
				<quad posn="0.25 0" sizen="39.45 3.5" halign="left" valign="center" bgcolor="fff8" />
				<quad posn="0.5 1.5 1" sizen="7 7" halign="left" valign="center" style="Emblems" substyle="#1" /> 
				<label posn="8 0.4 1" sizen="28 3.5" halign="left" valign="center" textsize="2" textemboss="1" text="{{{Teams[0].ColorizedName}}}" />
				<label posn="37 0.4 1" sizen="2.5 3.5" halign="left" valign="center" textsize="2" textemboss="1" text="{{{UIManager.UIAll.ScoreSummary_MatchPoints1}}}" />
			</frame>
			<frame posn="0 -3">
				<format textemboss="1" textsize="1.5" />
				{{{PlayersLists[1]}}}
			</frame>
		</frame>
		<frame posn="160 0" id="Frame_PlayersList_2">
			<frame id="Frame_TeamName_2">
				<quad posn="-0.25 0" sizen="39.45 3.5" halign="right" valign="center" bgcolor="fff8" />
				<quad posn="-0.5 1.5 1" sizen="7 7" halign="right" valign="center" style="Emblems" substyle="#2" /> 
				<label posn="-8 0.4 1" sizen="28 3.5" halign="right" valign="center" textsize="2" textemboss="1" text="{{{Teams[1].ColorizedName}}}" />
				<label posn="-37 0.4 1" sizen="2.5 3.5" halign="right" valign="center" textsize="2" textemboss="1" text="{{{UIManager.UIAll.ScoreSummary_MatchPoints2}}}" />
			</frame>
			<frame posn="0 -3">
				<format textemboss="1" textsize="1.5" />
				{{{PlayersLists[2]}}}
			</frame>
		</frame>
	</frame>
</frame>
""";
}

// ---------------------------------- //
/** Create the pre turn layer
 *
 *	@return 	The manialink
 */
// @UIReplay > 
Text CreateLayerPreTurn(Text _TeamAtkName, Text _TeamDefName, Text _NextAtkName) {
	declare VsText = _TeamAtkName^" attack - defense "^_TeamDefName;
	declare AtkName = "$<"^_NextAtkName^"$> is attacking!";
	return """
<frame posn="0 58">
	<label halign="center" style="TextRaceMessageBig" textsize="3" text="{{{VsText}}}" />
	<label posn="0 -4" halign="center" style="TextRaceMessageBig" text="{{{AtkName}}}" />
</frame>""";
}

// ---------------------------------- //
/** Create the player layer
 *
 *	@return 	The manialink used by the player layer
 */
Text CreateLayerPlayers() {
	declare ImgPath = "file://Media/Manialinks/Shootmania/Common/";
	declare ImgPathElite = "file://Media/Manialinks/Shootmania/Elite/";
	declare Team1Color = Teams[0].ColorPrimary.X^" "^Teams[0].ColorPrimary.Y^" "^Teams[0].ColorPrimary.Z;
	declare Team2Color = Teams[1].ColorPrimary.X^" "^Teams[1].ColorPrimary.Y^" "^Teams[1].ColorPrimary.Z;
	declare Logins = [1 => "", 2 => ""];
	
	declare PlayersLists = [1 => "", 2 => ""];
	declare DefendersLogins = "";
	declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	
	for (I, 1, 2) {
		declare First = True;
		foreach (Slot => Id in ClansOrders[I]) {
			if (Players.existskey(Id)) {
				declare Player <=> Players[Id];
				if (!First) Logins[I] ^= ",";
				Logins[I] ^= Player.Login;
				if (First) First = False;
				
				declare Align = "left";
				if (I == 2) Align = "right";
				PlayersLists[I] ^= """
<playerlist posn="0 {{{-2+(-4.5*(Slot-1))}}}" scale="0.67" halign="{{{Align}}}" substyle="Medium" logins="{{{Player.Login}}}" lines="1" columns="1" team="{{{I}}}" status="Playing"/>
""";
			}
		}
	}
	
	if (ClansOrders.existskey(G_DefClan)) {
		for (J, 1, 3) {
			declare DefenderLogin = "";
			if (ClansOrders[G_DefClan].existskey(J) && Players.existskey(ClansOrders[G_DefClan][J])) DefenderLogin = Players[ClansOrders[G_DefClan][J]].Login;
			DefendersLogins ^= """declare DefenderLogin{{{J}}} = "{{{DefenderLogin}}}";""";
		}
	}
	
	return """
<framemodel posn="0 0" id="FrameModel_HitDetailLeft">
	<quad posn="0 0" sizen="3.5 3.5" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="4 0" sizen="3.5 3.5" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="8 0" sizen="3.5 3.5" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="12 0" sizen="3.5 3.5" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="16 0" sizen="3.5 3.5" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
</framemodel>
<framemodel posn="0 0" id="FrameModel_HitDetailRight">
	<quad posn="0 0" sizen="3.5 3.5" halign="right" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="-4 0" sizen="3.5 3.5" halign="right" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="-8 0" sizen="3.5 3.5" halign="right" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="-12 0" sizen="3.5 3.5" halign="right" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
	<quad posn="-16 0" sizen="3.5 3.5" halign="right" valign="center" image="{{{ImgPath}}}WpRocket.dds" colorize="0.5 0.5 0.5" hidden="1" />
</framemodel>

<frame id="Frame_PlayersLists">
	<frame class="LibCustomUI_Module" id="Elite_PlayersList_1">
		<frame posn="-160 72" id="Frame_PlayersList_1">
			<frame id="Frame_TeamName_1" hidden="1">
				<quad posn="0.25 0" sizen="39.45 3.5" halign="left" valign="center" bgcolor="fff8" />
				<quad posn="0.5 1.5 1" sizen="7 7" halign="left" valign="center" style="Emblems" substyle="#1" /> 
				<label posn="8 0.4 1" sizen="28 3.5" halign="left" valign="center" textsize="2" textemboss="1" text="Blue" id="Label_Team1Name" />
				<label posn="37 0.4 1" sizen="2.5 3.5" halign="left" valign="center" textsize="2" textemboss="1" text="0" id="Label_MatchPoints1" />
			</frame>
			{{{PlayersLists[1]}}}
			<frame posn="41 -4.5 10">
				<frame posn="0  0"><frameinstance modelid="FrameModel_HitDetailLeft" id="Frame_HitDetail_1" /></frame>
				<frame posn="0 -4.5"><frameinstance modelid="FrameModel_HitDetailLeft" id="Frame_HitDetail_2" /></frame>
				<frame posn="0 -9"><frameinstance modelid="FrameModel_HitDetailLeft" id="Frame_HitDetail_3" /></frame>
			</frame>
		</frame>
	</frame>
	<frame class="LibCustomUI_Module" id="Elite_PlayersList_2">
		<frame posn="160 72" id="Frame_PlayersList_2">
			<frame id="Frame_TeamName_2" hidden="1">
				<quad posn="-0.25 0" sizen="39.45 3.5" halign="right" valign="center" bgcolor="fff8" />
				<quad posn="-0.5 1.5 1" sizen="7 7" halign="right" valign="center" style="Emblems" substyle="#2" /> 
				<label posn="-8 0.4 1" sizen="28 3.5" halign="right" valign="center" textsize="2" textemboss="1" text="Red" id="Label_Team2Name" />
				<label posn="-37 0.4 1" sizen="2.5 3.5" halign="right" valign="center" textsize="2" textemboss="1" text="0" id="Label_MatchPoints2" />
			</frame>
			{{{PlayersLists[2]}}}
			<frame posn="-41 -4.5 10">
				<frame posn="0  0"><frameinstance modelid="FrameModel_HitDetailRight" id="Frame_HitDetail_1" /></frame>
				<frame posn="0 -4.5"><frameinstance modelid="FrameModel_HitDetailRight" id="Frame_HitDetail_2" /></frame>
				<frame posn="0 -9"><frameinstance modelid="FrameModel_HitDetailRight" id="Frame_HitDetail_3" /></frame>
			</frame>
		</frame>
	</frame>
</frame>
<script><!--
#Include "TextLib" as TL

#Const C_UpdateInterval 200

declare CMlFrame[Integer] Frame_PlayersList;
declare CMlFrame[Integer] Frame_TeamName;
declare CMlFrame[Integer][Integer] Frame_HitDetail;
declare CMlQuad Quad_LatestHit;
declare Ident[Integer][Integer] G_Slots;

Void UpdateSlot(Integer _Clan, Integer _Order, Ident _PlayerId) {
	if (Frame_HitDetail.existskey(_Clan) && Frame_HitDetail[_Clan].existskey(_Order)) {
		if (_PlayerId == NullId || !Players.existskey(_PlayerId)) {
			Frame_HitDetail[_Clan][_Order].Hide();
		} else {
			declare netread Integer[] Net_Elite_HitDetail for Players[_PlayerId];
			if (Quad_LatestHit != Null) Quad_LatestHit.RelativeScale = 1.;
			
			Frame_HitDetail[_Clan][_Order].Show();
			declare I = 0;
			foreach (Control in Frame_HitDetail[_Clan][_Order].Controls) {
				declare Quad_Hit <=> (Control as CMlQuad);
				if (Net_Elite_HitDetail.existskey(I)) {
					Quad_Hit.Show();
					Quad_LatestHit <=> Quad_Hit;
					switch (Net_Elite_HitDetail[I]) {
						case {{{GetWeaponNum(CSmMode::EWeapon::Laser)}}}: {
							Quad_Hit.ChangeImageUrl("{{{ImgPath}}}WpLaser.dds");
						}
						case {{{GetWeaponNum(CSmMode::EWeapon::Rocket)}}}: {
							Quad_Hit.ChangeImageUrl("{{{ImgPath}}}WpRocket.dds");
						}
						case {{{GetWeaponNum(CSmMode::EWeapon::Nucleus)}}}: {
							Quad_Hit.ChangeImageUrl("{{{ImgPath}}}WpNucleus.dds");
						}
						case {{{GetWeaponNum(CSmMode::EWeapon::Arrow)}}}: {
							Quad_Hit.ChangeImageUrl("{{{ImgPath}}}WpArrows.dds");
						}
					}
				} else {
					Quad_Hit.Hide();
				}
				I += 1;
			}
			if (Quad_LatestHit != Null) Quad_LatestHit.RelativeScale = 1.5;
		}
	}
}

main() {
	declare Frame_PlayersLists	<=> (Page.GetFirstChild("Frame_PlayersLists")				as CMlFrame);
	declare Label_Team1Name		<=> (Frame_PlayersLists.GetFirstChild("Label_Team1Name")	as CMlLabel);
	declare Label_Team2Name		<=> (Frame_PlayersLists.GetFirstChild("Label_Team2Name")	as CMlLabel);
	declare Label_MatchPoints1	<=> (Frame_PlayersLists.GetFirstChild("Label_MatchPoints1")	as CMlLabel);
	declare Label_MatchPoints2	<=> (Frame_PlayersLists.GetFirstChild("Label_MatchPoints2")	as CMlLabel);
	
	for (K, 1, 2) {
		Frame_PlayersList[K]	<=> (Frame_PlayersLists.GetFirstChild("Frame_PlayersList_"^K) as CMlFrame);
		Frame_TeamName[K]		<=> (Frame_PlayersLists.GetFirstChild("Frame_TeamName_"^K) as CMlFrame);
		Frame_HitDetail[K] = CMlFrame[Integer];
		G_Slots[K] = Ident[Integer];
		for (L, 1, 3) {
			Frame_HitDetail[K][L] <=> (Frame_PlayersList[K].GetFirstChild("Frame_HitDetail_"^L) as CMlFrame);
			G_Slots[K][L] = NullId;
		}
	}
	
	declare PrevTeam1Name = "";
	declare PrevTeam2Name = "";
	declare PrevIsSpectator = False;
	declare PrevMatchPoints1 = 0;
	declare PrevMatchPoints2 = 0;
	declare NextUpdate = 0;
	
	{{{DefendersLogins}}}
	
	declare netread Text[Integer][Integer] Net_Elite_PlayersOrder for Teams[0];
	
	{{{CustomUI::InjectMLInit()}}}
	
	while (True) {
		yield;
		
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		{{{CustomUI::InjectMLLoop()}}}
		
		if (Now >= NextUpdate) {
			NextUpdate = Now + C_UpdateInterval;
			
			if (PrevTeam1Name != Teams[0].ColorizedName) {
				PrevTeam1Name = Teams[0].ColorizedName;
				Label_Team1Name.SetText(Teams[0].ColorizedName);
			}
			if (PrevTeam2Name != Teams[1].ColorizedName) {
				PrevTeam2Name = Teams[1].ColorizedName;
				Label_Team2Name.SetText(Teams[1].ColorizedName);
			}
			
			if (PrevMatchPoints1 != UI.ScoreSummary_MatchPoints1) {
				PrevMatchPoints1 = UI.ScoreSummary_MatchPoints1;
				Label_MatchPoints1.SetText(TL::ToText(UI.ScoreSummary_MatchPoints1));
			}
			if (PrevMatchPoints2 != UI.ScoreSummary_MatchPoints2) {
				PrevMatchPoints2 = UI.ScoreSummary_MatchPoints2;
				Label_MatchPoints2.SetText(TL::ToText(UI.ScoreSummary_MatchPoints2));
			}
			
			if (PrevIsSpectator != IsSpectatorMode) {
				PrevIsSpectator = IsSpectatorMode;
				if (IsSpectatorMode) {
					Frame_PlayersList[1].RelativeScale = 1.2;
					Frame_PlayersList[2].RelativeScale = 1.2;
					Frame_PlayersList[1].RelativePosition.Y = 67.75;
					Frame_PlayersList[2].RelativePosition.Y = 67.75;
					Frame_TeamName[1].Show();
					Frame_TeamName[2].Show();
				} else {
					Frame_PlayersList[1].RelativeScale = 1.;
					Frame_PlayersList[2].RelativeScale = 1.;
					Frame_PlayersList[1].RelativePosition.Y = 72.;
					Frame_PlayersList[2].RelativePosition.Y = 72.;
					Frame_TeamName[1].Hide();
					Frame_TeamName[2].Hide();
				}
			}
			
			for (I, 1, 2) {
				for (J, 1, 3) {
					if (G_Slots[I][J] == NullId) {
						if (Net_Elite_PlayersOrder.existskey(I) && Net_Elite_PlayersOrder[I].existskey(J)) {
							foreach (Player in Players) {
								if (!Player.RequestsSpectate && Player.Login == Net_Elite_PlayersOrder[I][J]) {
									G_Slots[I][J] = Player.Id;
									UpdateSlot(I, J, Player.Id);
								}
							}
						}
					} else if (!Players.existskey(G_Slots[I][J])) {
						G_Slots[I][J] = NullId;
						UpdateSlot(I, J, NullId);
					} else {
						declare Player <=> Players[G_Slots[I][J]];
						declare PrevRequestsSpectate for Player = False;
						declare netread Text Net_Elite_HitDetailUpdate for Player;
						declare PrevHitDetailUpdate for Player = "";
						
						if (PrevRequestsSpectate != Player.RequestsSpectate) {
							PrevRequestsSpectate = Player.RequestsSpectate;
							if (Player.RequestsSpectate) {
								G_Slots[I][J] = NullId;
								UpdateSlot(I, J, NullId);
							} else {
								G_Slots[I][J] = Player.Id;
								UpdateSlot(I, J, Player.Id);
							}
						} else if (PrevHitDetailUpdate != Net_Elite_HitDetailUpdate) {
							PrevHitDetailUpdate = Net_Elite_HitDetailUpdate;
							UpdateSlot(I, J, Player.Id);
						}
					}
				}
			}
		}
	}
}
--></script>
""";
}

// ---------------------------------- //
// Update the players layer
Void UpdateLayerPlayers() {
	declare ClansOrders = [1 => WarmUp2::GetGroup("Clan1"), 2 => WarmUp2::GetGroup("Clan2")];
	declare netwrite Text[Integer][Integer] Net_Elite_PlayersOrder for Teams[0];
	for (I, 1, 2) {
		declare J = 1;
		Net_Elite_PlayersOrder[I] = Text[Integer];
		foreach (Slot => Id in ClansOrders[I]) {
			if (Players.existskey(Id)) {
				Net_Elite_PlayersOrder[I][Slot] = Players[Id].Login;
			}
		}
	}
}

// ---------------------------------- //
/// Update the Hud3dMarkers.
Void UpdateMarkers() {
	declare CheckpointIndex = 1;
	// Set the marker above the goal
	UIManager.UIAll.MarkersXML = "";
	foreach (Goal in MapLandmarks_Gauge) {
		declare Name = "";
		declare Type = "";
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 25;
		declare PosZ = Goal.Position.Z;
		if (Goal.Tag == "Goal A") {
			Name = "$wA";
			Type = "icon=\"PointA\"";
		} else if (Goal.Tag == "Goal B") {
			Name = "$wB";
			Type = "icon=\"PointB\"";
		} else if (Goal.Tag == "Goal C") {
			Name = "$wC";
			Type = "icon=\"PointC\"";
		} else if (Goal.Tag == "Checkpoint" && Goal.Gauge.Value <= 0) {
			Name = "$w"^CheckpointIndex;
			Type = """label="{{{Name}}}" """;
			CheckpointIndex += 1;
			PosY = Goal.Position.Y + 4;
		}
		
		if (Name == "") continue;
		
		UIManager.UIAll.MarkersXML ^= """
			<marker {{{Type}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";
	}
}

// ---------------------------------- //
/** Custom Elite stringify for CSmModeEvent
 *
 *	@param	_Name		The name of the stringified object
 *	@param	_Event		The event to stringify
 */
Text EliteStringify(Text _Name, CSmModeEvent _Event) {
	declare JSON = "";
	
	switch (_Event.Type) {
		case CSmModeEvent::EType::OnShoot: {
			JSON = PlayerStringify("Shooter", _Event.Shooter, True);
		}
		case CSmModeEvent::EType::OnHit: {
			declare HitDist = 0.;
			if (
				_Event.Victim != Null
				&& _Event.Shooter != Null
			) {
				HitDist = MathLib::NearestInteger(MathLib::Distance(_Event.Victim.Position, _Event.Shooter.Position) * 1000.) / 1000.;
			}
			JSON = Json::Merge([
				Json::Stringify("HitDist", HitDist),
				PlayerStringify("Shooter", _Event.Shooter, True),
				PlayerStringify("Victim", _Event.Victim, True)
			]);
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			JSON = Json::Merge([
				PlayerStringify("Shooter", _Event.Shooter, True),
				PlayerStringify("Victim", _Event.Victim, True)
			]);
		}
		case CSmModeEvent::EType::OnCapture: {
			declare AtkPlayer <=> CSmPlayer;
			if (Players.existskey(G_AtkPlayerId)) {
				AtkPlayer <=> Players[G_AtkPlayerId];
			}
			JSON = Json::Merge([
				PlayerStringify("Player", AtkPlayer),
				Json::StringifyMinimal("Pole", _Event.Landmark, "")
			]);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			JSON = PlayerStringify("Player", _Event.Player);
		}
		case CSmModeEvent::EType::OnNearMiss: {
			declare HitDist = 0.;
			if (
				_Event.WeaponNum == C_WeaponLaser
				&& _Event.Victim != Null
				&& _Event.Shooter != Null
			) {
				HitDist = MathLib::NearestInteger(MathLib::Distance(_Event.Victim.Position, _Event.Shooter.Position) * 1000.) / 1000.;
			}
			declare MissDist = _Event.MissDist;
			if (MissDist < 0.0001) MissDist = 0.0001;
			JSON = Json::Merge([
				Json::Stringify("MissDist", MissDist),
				Json::Stringify("HitDist", HitDist),
				PlayerStringify("Shooter", _Event.Shooter),
				PlayerStringify("Victim", _Event.Victim)
			]);
		}
	}
	
	JSON = Json::Merge([
		TurnStringify(),
		Json::StringifyMinimal(_Name, _Event, JSON)
	]);
	
	return JSON;
}

// ---------------------------------- //
/** Simulate an AmorEmptyEvent
 *
 *	@param	_Name		The name of the stringified object
 *	@param	_Event		The event to stringify
 */
Text EliteStringifySimulateArmorEmpty(Text _Name, CSmModeEvent _Event) {
	declare JSON = "";
	
	JSON = Json::Merge([
		PlayerStringify("Shooter", _Event.Shooter, True),
		PlayerStringify("Victim", _Event.Victim, True)
	]);
	
	declare EventJSON = "";
	declare More = "";
	if (JSON != "") More = ","^JSON;
	
	if (_Event != Null) {
		EventJSON = """
"{{{_Name}}}":
{
	"Type": "EType::OnArmorEmpty",
	"Damage": {{{_Event.Damage}}},
	"WeaponNum": {{{_Event.WeaponNum}}},
	"MissDist": {{{_Event.MissDist}}}
	{{{More}}}
}
""";
	} else {
		EventJSON = """"{{{_Name}}}": null""";
	}
	
	JSON = Json::Merge([
		TurnStringify(),
		EventJSON
	]);	
	
	return JSON;
}


Void CreateRulesReminderLayer() {
	if(! S_DisplayRulesReminder) return;

	declare Text ImgBaseDir			= "file://Media/Manialinks/Shootmania/Common/";
	//declare Text WelcomeBgImage		= ImgBaseDir^"WelcomeBg.dds";
	declare Text WelcomeBgImage		= ImgBaseDir^"topsBg.dds";
	declare Text ArmorImage			= ImgBaseDir^"ShieldWhite.dds";
	declare Text WpLaserImage		= ImgBaseDir^"WpLaser.dds";
	declare Text WpRocketImage		= ImgBaseDir^"WpRocket.dds";
	declare Text HighlightColor		= "f90";
	declare Text CAlign				= """ valign="center" halign="center" """;
	
	declare Text TitleText 			= TextLib::Compose(_("Welcome to %1!"), "Elite");
	declare Text DoNotShowAgain		= _("Do Not Show Again");
	declare Text Close				= _("Close");
	
	declare Integer WindowWidth		= 160;
	declare Integer WindowHeight	= 75;
	declare Real 	WindowX			= 0.;
	declare Real 	WindowY			= 0.;
	
	declare Real	YOffset			= 3.5;
	declare Real	ArmorSize		= 4.;
	declare Real	WeaponSize		= 9.;
	declare Real	SpecSize		= 5.;
	
	declare Text	DarkBg 			= "0006";
	
	declare Text MLText = """
	<script><!--
		while(InputPlayer == Null) yield;
		
		// for the "do not show again" feature		
		declare persistent Boolean NadeoElite_PersistentShowRulesReminder for This = True;
		// NadeoElite_PersistentShowRulesReminder = True; // Uncomment for testing purpose
		
		if(! NadeoElite_PersistentShowRulesReminder) {
			return;
		}
		
		declare Button_DoNotShowAgain 	<=> (Page.GetFirstChild("Button_DoNotShowAgain") as CMlLabel);
		declare Button_Close 			<=> (Page.GetFirstChild("Button_Close") as CMlLabel);
		declare RulesReminderMainFrame 	<=> (Page.GetFirstChild("RulesReminderMainFrame") as CMlFrame);
		
		while(True) {
			yield;
			
			if(IsSpectatorMode) {
				RulesReminderMainFrame.Hide();
				continue;
			} else {
				RulesReminderMainFrame.Show();
			}
			
			foreach(Event in PendingEvents) {
				switch(Event.Type){
					case CMlEvent::Type::MouseClick: {
						if(Event.ControlId == "Button_DoNotShowAgain") {
							NadeoElite_PersistentShowRulesReminder = False;
							RulesReminderMainFrame.Hide();
							return; // End of this behavior
						}
						if(Event.ControlId == "Button_Close") {
							RulesReminderMainFrame.Hide();
							return; // End of this behavior
						}
					}
					case CMlEvent::Type::KeyPress: {
						if(Event.CharPressed == "2424832" ) { // F1
							RulesReminderMainFrame.Hide();
							return; // End of this behavior
						}
					}
				}
			}
		}
		
	--></script>
	<frame id="RulesReminderMainFrame" hidden="true" posn="{{{WindowX}}} {{{WindowY}}} 100" >
		<quad  posn="0 9 -2" 	{{{CAlign}}} sizen="{{{WindowWidth + 20}}} {{{WindowHeight + 75}}}" image="{{{WelcomeBgImage}}}" />
		<label posn="0 {{{(WindowHeight/2)-5}}}" 	halign="center" valign="center" text="{{{TitleText}}}"  textsize="7"/>
		<frame id="Rules" posn="0 {{{(WindowHeight/2)-14}}}" {{{CAlign}}} scale="1." >
			<quad sizen="{{{WindowWidth+6}}} {{{3*YOffset}}}" bgcolor="{{{DarkBg}}}" {{{CAlign}}} posn="0 {{{-6*YOffset -3}}} -1"/>
			<label posn="0 {{{-2*YOffset}}}" id="Rules_versus" text="VS" {{{CAlign}}} textsize="4"/>
			
			<frame id="Rules_LeftFrame" posn="{{{-(WindowWidth/2)+10}}} {{{-3*YOffset-3}}}" >
				<frame id="Frame_LeftTeam" posn="0 -2">
					<label posn="24 15.5" text="{{{TextLib::Compose("%1 1", _("Team"))}}}" textprefix="$t" textsize="1"/>
					<frame posn="{{{WindowWidth/4 - 10}}} {{{3*YOffset}}}">
						<label text="{{{TextLib::Compose("1 %1", _("Attacker"))}}}"  {{{CAlign}}}  textcolor="f90"/>
						<quad  posn="-17 1" image="{{{WpLaserImage}}}"  sizen="{{{WeaponSize}}} {{{WeaponSize}}}" colorize="f90" {{{CAlign}}}/>
					</frame>
					<frame posn="{{{WindowWidth/4 - 10}}} {{{YOffset+2.5}}}" >
						<label text="{{{TextLib::Compose("2 %1", _("Spectators"))}}}"  {{{CAlign}}}  textsize="1"/>
						<!--<quad  posn="-12 0" style="Icons64x64_1" substyle="Camera" sizen="{{{SpecSize}}} {{{SpecSize}}}" {{{CAlign}}}/>-->
					</frame>
				</frame>
				<frame id="Frame_LeftRules" posn="0 -3">
					<label posn="{{{WindowWidth/4 - 10}}} {{{-2*YOffset}}}" id="Rules_Left_Objectives" sizen="68 5"
					text="{{{_("Eliminate the defenders or capture the pole at the end of the round.")}}}" textsize="1" autonewline="1" {{{CAlign}}} scale="1.1"/>
					<frame posn="{{{WindowWidth/4 - 23}}} {{{-5.*YOffset}}}" >
						<label posn="0 0" text="{{{_("Armor")}}}" textsize="1" {{{CAlign}}} textprefix="$t"/>
						<frame posn="12 0">
							<quad  posn="0  0" image="{{{ArmorImage}}}" sizen="{{{ArmorSize}}} {{{ArmorSize}}}" {{{CAlign}}}/>
							<quad  posn="5  0" image="{{{ArmorImage}}}" sizen="{{{ArmorSize}}} {{{ArmorSize}}}" {{{CAlign}}} />
							<quad  posn="10 0" image="{{{ArmorImage}}}" sizen="{{{ArmorSize}}} {{{ArmorSize}}}" {{{CAlign}}} />
						</frame>
					</frame>
				</frame>
			</frame>
			
			<quad sizen="0.3 {{{7*YOffset}}} -1" bgcolor="ffff" {{{CAlign}}} posn="0  {{{-7*YOffset}}}"/>
			
			<frame id="Rules_RightFrame" posn="{{{5}}} {{{-3*YOffset-3}}}" >
				<frame id="Frame_LeftTeam" posn="0 -2">
					<label posn="35 15.5" text="{{{TextLib::Compose("%1 2", _("Team"))}}}" textprefix="$t" textsize="1"/>
					<frame posn="{{{WindowWidth/4+3}}} {{{3*YOffset}}}">
						<label text="{{{TextLib::Compose("3 %1", _("Defenders"))}}}"  {{{CAlign}}}  textcolor="f90"/>
						<quad  posn="-20 1" image="{{{WpRocketImage}}}"  sizen="{{{WeaponSize}}} {{{WeaponSize}}}" colorize="f90" {{{CAlign}}}/>
					</frame>
					<label posn="43 6.5" text="{{{_("Playing this round altogether")}}}"  {{{CAlign}}}  textsize="1"/>
				</frame>
				
				<frame id="Frame_LeftRules" posn="0 -3">
					<label posn="{{{WindowWidth/4}}} {{{-2*YOffset}}}" id="Rules_Left_Objectives" sizen="68 5" 
					text="{{{_("Eliminate the attacker or prevent the pole from being captured.")}}}" textsize="1" autonewline="1" {{{CAlign}}} scale="1.1"/>
					<frame posn="{{{WindowWidth/4 -8}}} {{{-5.*YOffset}}}" >
						<label posn="0 0" text="{{{_("Armor")}}}" textsize="1" {{{CAlign}}} textprefix="$t"/>
						<quad  posn="12 0" image="{{{ArmorImage}}}" sizen="{{{ArmorSize}}} {{{ArmorSize}}}" {{{CAlign}}}/>
					</frame>
				</frame>
			</frame>
		</frame>
		
		<frame id="buttons" posn="0 {{{-(WindowHeight/2)+2}}}" {{{CAlign}}}>
			<label posn=" 19 0" text="{{{DoNotShowAgain}}}" style="CardButtonSmall" ScriptEvents="true" id="Button_DoNotShowAgain" {{{CAlign}}}/>
			<label posn="-19 0" text="{{{Close}}}" style="CardButtonSmall" ScriptEvents="true" id="Button_Close" {{{CAlign}}}/>
		</frame>
		<label halign="center" 	valign="bottom"	posn="0 {{{-(WindowHeight/2) + 10}}}"  text="{{{
				TextLib::Compose(_("Press '$<%1F1$>' to close this window."), "$"^HighlightColor)}}}" />
		<label halign="center" 	valign="bottom"	posn="0 {{{-(WindowHeight/2) + 6}}}"  text="{{{
				TextLib::Compose(_("Hold '$<%1alt$>' to free the cursor."), "$"^HighlightColor)}}}" textsize="2"/>
	</frame>
	""";
	
	Layers::Create("RulesReminder", MLText);
	Layers::SetType("RulesReminder", CUILayer::EUILayerType::CutScene);
	Layers::Attach("RulesReminder");
}